from LSQ.entity import Signal, RTLComment, DeclarativeUnit
from LSQ.config import Config

from LSQ.utils import QueueType, QueuePointerType

from LSQ.rtl_signal_names import *

from LSQ.operators.arithmetic import WrapSub  

import LSQ.declarative_signals as ds

from LSQ.utils import bin_string

 
class GroupHandshaking(DeclarativeUnit):
    def __init__(self, config : Config, parent):
        self.top_level_comment = f"""
-- Group Initiation Handshaking Unit
-- Sub-unit of the Group Allocator.
--
-- Generates the local "group init channel transfer" signals
-- as well as the output "group init channel ready" signals
--
-- Without multi-group assignment enabled,
-- the ready signal to a group is based on how empty/full the current
-- load and store queue are.
--
-- If there is enough space to allocate the group,
-- the ready signal is set high.
--
-- The transfer signal is the "and" of the ready and valid signals.
""".strip()
            
        self.unit_name = GROUP_HANDSHAKING_NAME
        self.parent = parent


        d = Signal.Direction

        # Declarative list of signals in
        # the entity port mapping
        self.entity_port_items = [
            ########################################
            # Comment + init valid + init ready

            RTLComment(f"""  
    -- Group init channels from the dataflow circuit
    -- {config.num_groups()} control channel(s),
    -- One for each group of memory operations.

"""),
            ds.GroupInitValid(config),
            ds.GroupInitReady(config),

            ########################################

            # RTL Comment + load q tail pointer + load q head pointer
            # + load q is empty signal
            RTLComment(f"""
    -- Inputs from the load queue.
    -- Used to see if there is enough space to allocate each group.

"""),
            ds.QueuePointer(
                config, 
                QueueType.LOAD, 
                QueuePointerType.TAIL,
                d.INPUT
            ),
            ds.QueuePointer(
                config, 
                QueueType.LOAD, 
                QueuePointerType.HEAD,
                d.INPUT
            ),
            ds.QueueIsEmpty(
                QueueType.LOAD,
                d.INPUT
            ),

            ########################################

            # RTL comment + store q tail pointer + store q trail pointer
            # + store q is empty siganl
            RTLComment(f"""    
    -- Inputs from the store queue.
    -- Used to see if there is enough space to allocate each group.

"""),
            ds.QueuePointer(
                config, 
                QueueType.STORE, 
                QueuePointerType.TAIL,
                d.INPUT
            ),
            ds.QueuePointer(
                config, 
                QueueType.STORE, 
                QueuePointerType.HEAD,
                d.INPUT
            ),
            ds.QueueIsEmpty(
                QueueType.STORE,
                d.INPUT
            ),

            ########################################

            # RTL comment + group init transfer signal
            RTLComment(f"""             
    -- A boolean per group init channel
    -- to see if the group is being allocated this cycle.
    -- Used to decide what the group allocator writes
    -- to the load and store queue.

"""),

            ds.GroupInitTransfer(
                config, 
                d.OUTPUT)

            ########################################
        ]
        # end of declarative list of 
        # entity port map signal
        ########################################


        # Declarative list of local signals
        self.local_items = [
            # naive num entry signals 
            # to check if there is space to allocate group
            NaiveNumEmptyEntries(
                config, 
                QueueType.LOAD
            ),
            NaiveNumEmptyEntries(
                config, 
                QueueType.STORE
            ),
            
            # local version of init ready
            ds.GroupInitReady(config)
        ]

        # Body is non-declarative
        self.body = [
            GroupHandshakingBody(config)
        ]


class GroupHandshakingBody():
        """
        Class generating the RTL code for the body of 
        group handshaking, a sub-unit of the group allocator.
        """
        def get(self):
            return self.body

        def __init__(self, config : Config):

            self.body = f"""
  -- The (naive) number of empty entries in the load queue
  -- is generated by a wrap-around subtraction.
  -- it is naive since it will be incorrect when the queue is empty
  {self._get_naive_num_empty_entries(config, QueueType.LOAD)}

  -- The (naive) number of empty entries in the store queue
  -- is generated by a wrap-around subtraction.
  -- it is naive since it will be incorrect when the queue is empty
  {self._get_naive_num_empty_entries(config, QueueType.STORE)}

  {self._get_ready_when_statements(config)}

  {self._get_output_assignments(config)}

""".removeprefix("\n")
                

        def _get_naive_num_empty_entries(self, 
                                         config : Config,
                                         queue_type : QueueType):
            """
            Get the calculation for the number of empty entries in
            the (store/load) queue using wrap-around subtraction
            of the head and tail pointer.
            """
            empty_entries_naive = NUM_EMPTY_ENTRIES_NAIVE_NAME(queue_type)
        
            head_pointer = QUEUE_POINTER_NAME(queue_type, QueuePointerType.HEAD)
            tail_pointer = QUEUE_POINTER_NAME(queue_type, QueuePointerType.TAIL)

            queue_num_entries = config.queue_num_entries(queue_type)

            wrap_sub_return = WrapSub(
                output_signal = empty_entries_naive, 
                lhs_signal = f"{head_pointer}_i", 
                rhs_signal = f"{tail_pointer}_i", 
                wrap_max = queue_num_entries
                )

            if wrap_sub_return.single_line:
                return f"""
  {wrap_sub_return.line1}
""".strip()
            else:
                return f"""
  {wrap_sub_return.line1}
    {wrap_sub_return.line2}
    {wrap_sub_return.line3}
    {wrap_sub_return.line4}
""".strip()
            

        def _get_ready_when_statements(self, config : Config):
            """
            Get the when statement for each group to calculate its ready signal.
            If there is not enough space in either queues, the signal is 0.
            Otherwise, the ready signal is 1.
            """
            load_empty_entries = NUM_EMPTY_ENTRIES_NAIVE_NAME(QueueType.LOAD)
            store_empty_entries = NUM_EMPTY_ENTRIES_NAIVE_NAME(QueueType.STORE)
            
            when_statements = ""
            for i in range(config.num_groups()):
                load_is_empty = f"{IS_EMPTY_NAME(QueueType.LOAD)}_i"
                store_is_empty = f"{IS_EMPTY_NAME(QueueType.STORE)}_i"

                group_init_ready = f"{GROUP_INIT_CHANNEL_NAME}_ready_{i}"
            
                num_loads = config.group_num_loads(i)
                num_stores = config.group_num_stores(i)

                # if the group allocates into the entire queue
                # checking just the empty signal is enough
                ld_q_num_entries = config.queue_num_entries(QueueType.LOAD)
                if num_loads == config.queue_num_entries(QueueType.LOAD):
                    num_empty_check_ld = ""
                    ld_q_percent = 100
                # otherwise not ready if num empty is less than num allocated
                else:
                    idx_bitwidth = config.queue_idx_bitwidth(QueueType.LOAD)
                    num_loads_binary = bin_string(num_loads, idx_bitwidth)

                    num_empty_check_ld = f" and {load_empty_entries} < {num_loads_binary}"

                    ld_q_percent = int(100 * num_loads / ld_q_num_entries)

                # if the group allocates into the entire queue
                # checking just the empty signal is enough
                st_q_num_entries = config.queue_num_entries(QueueType.STORE)
                if num_stores == st_q_num_entries:
                    num_empty_check_st = ""
                    st_q_percent = 100
                # otherwise not ready if num empty is less than num allocated
                else:
                    idx_bitwidth = config.queue_idx_bitwidth(QueueType.STORE)
                    num_stores_binary = bin_string(num_stores, idx_bitwidth)

                    num_empty_check_st = f" and {store_empty_entries} < {num_stores_binary}"

                    st_q_percent = int(100 * num_stores / st_q_num_entries)

                
                when_statements += f"""
  -- Group {i} has:
  --      {num_loads} load(s), {ld_q_percent}% of the queue
  --      {num_stores} store(s), {st_q_percent}% of the queue
  -- 
  -- To be ready to allocate a group,
  -- both queues must have enough space for the group's memory operations
  {group_init_ready} <= 
    '0' 
  when
    ({load_is_empty} = '0'{num_empty_check_ld})
      or
    ({store_is_empty} = '0'{num_empty_check_st})
  else 
    '1';

""".removeprefix("\n")
            
            return when_statements.strip()
                

        def _get_output_assignments(self, config : Config):
            """
            The init ready signal is local, 
            since it is used to calculate the init transfer output.

            However, it is also used as an output to the dataflow circuit.

            This generates an assignment for the
            group init ready output for each group,
            and also ands the ready with the group init valid to create
            the group init transfer signal.
            """
            assignments = ""

            # one ready and transfer signal per group
            for i in range(config.num_groups()):
                init_ready = f"{GROUP_INIT_CHANNEL_NAME}_ready_{i}"
                init_valid = f"{GROUP_INIT_CHANNEL_NAME}_valid_{i}_i"
                init_transfer = f"{GROUP_INIT_TRANSFER_NAME}_{i}_o"

                # ready output driven by local
                # transfer output driven by (valid and ready)
                assignments += f"""
  -- drive the ready output
  {init_ready}_o <= {init_ready};

  -- drive the transfer output
  {init_transfer} <= {init_valid} and {init_ready};

""".lstrip()
                
            return assignments.strip()
        
        
# Declarative local signal only used by the group handshaking unit
class NaiveNumEmptyEntries(Signal):
    """
    Bitwidth = N

    Number = 1

    Number of empty entries in a queue, naively calculated.
    Needs to be combined with isEmpty to calculate the real value.

    Same bitwidth as queue pointer.
    """

    def __init__(self, 
                    config : Config,
                    queue_type : QueueType,
                    ):

        Signal.__init__(
            self,
            base_name=NUM_EMPTY_ENTRIES_NAIVE_NAME(queue_type),
            size=Signal.Size(
                bitwidth=config.queue_idx_bitwidth(queue_type),
                number=1
            )
        )

