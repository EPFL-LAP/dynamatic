from LSQ.entity import Signal
from LSQ.config import Config

from LSQ.utils import QueueType, QueuePointerType

from LSQ.rtl_signal_names import *

from LSQ.operators.arithmetic import WrapSub  

from LSQ.generators.group_allocator.group_allocator_items import GroupAllocatorPortItems, GroupAllocatorLocalItems

import LSQ.declarative_signals as ds

 
class GroupHandshaking():
    def __init__(self, config : Config, prefix):
        self.top_level_comment = f"""
-- Group Initiation Handshaking Unit
-- Sub-unit of the Group Allocator.
--
-- Generates the local "group init channel transfer" signals
-- as well as the output "group init channel ready" signals
--
-- Without multi-group assignment enabled,
-- the ready signal to a group is based on how empty/full the current
-- load and store queue are.
--
-- If there is enough space to allocate the group,
-- the ready signal is set high.
--
-- The transfer signal is the "and" of the ready and valid signals.
""".strip()
            
        self.name = GROUP_HANDSHAKING_NAME
        self.prefix = prefix


        ga_p = GroupAllocatorPortItems()

        ga_l = GroupAllocatorLocalItems()

        d = Signal.Direction
        self.entity_port_items = [
            ds.GroupInitValid(config),
            ga_p.GroupInitReady(config),

            ga_p.QueuePointer(config, QueueType.LOAD, QueuePointerType.TAIL),
            ga_p.QueuePointer(config, QueueType.LOAD, QueuePointerType.HEAD),
            ga_p.QueueIsEmpty(QueueType.LOAD),

            ga_p.QueuePointer(config, QueueType.STORE, QueuePointerType.TAIL),
            ga_p.QueuePointer(config, QueueType.STORE, QueuePointerType.HEAD),
            ga_p.QueueIsEmpty(QueueType.STORE),

            ga_l.GroupInitTransfer(config, d.OUTPUT)
        ]


        self.local_items = [
            NaiveNumEmptyEntries(config, QueueType.LOAD),
            NaiveNumEmptyEntries(config, QueueType.STORE),

            ga_p.GroupInitReady(config)
        ]

        self.body = [
            GroupHandshakingBody(config)
        ]


class GroupHandshakingBody():
        """
        Class generating the RTL code for the body of 
        group handshaking, a sub-unit of the group allocator.
        """
        def get(self):
            return self.item

        def __init__(self, config : Config):
            load_empty_entries = NUM_EMPTY_ENTRIES_NAIVE_NAME(QueueType.LOAD)
            store_empty_entries = NUM_EMPTY_ENTRIES_NAIVE_NAME(QueueType.STORE)


            self.item = f"""
  -- The (naive) number of empty entries in the load queue
  -- is generated by a wrap-around subtraction.
  -- it is naive since it will be incorrect when the queue is empty
  {self._get_naive_num_empty_entries(config, QueueType.LOAD)}

  -- The (naive) number of empty entries in the store queue
  -- is generated by a wrap-around subtraction.
  -- it is naive since it will be incorrect when the queue is empty
  {self._get_naive_num_empty_entries(config, QueueType.STORE)}

  -- process to generate the ready signals for the group init channels
  -- by checking the number of empty elements vs. 
  -- the number of loads and stores in that group of memory operations
  -- to see if there is space to allocate them.
  -- if either queue does not have enough space, the group allocator is not ready
  process(all)
    variable {load_empty_entries}_int : natural;
    variable {store_empty_entries}_int : natural;
  begin
    {load_empty_entries}_int := to_integer(unsigned({load_empty_entries}));
    {store_empty_entries}_int := to_integer(unsigned({store_empty_entries}));

    {self._get_ready_if_statements(config)}

  end process;

    {self._get_output_assignments(config)}

""".removeprefix("\n")
                

        def _get_naive_num_empty_entries(self, 
                                         config : Config,
                                         queue_type : QueueType):
            """
            Get the calculation for the number of empty entries in
            the (store/load) queue using wrap-around subtraction
            of the head and tail pointer.
            """
            empty_entries_naive = NUM_EMPTY_ENTRIES_NAIVE_NAME(queue_type)
        
            head_pointer = QUEUE_POINTER_NAME(queue_type, QueuePointerType.HEAD)
            tail_pointer = QUEUE_POINTER_NAME(queue_type, QueuePointerType.TAIL)

            queue_num_entries = config.queue_num_entries(queue_type)

            wrap_sub_return = WrapSub(
                output_signal = empty_entries_naive, 
                lhs_signal = f"{head_pointer}_i", 
                rhs_signal = f"{tail_pointer}_i", 
                wrap_max = queue_num_entries
                )

            if wrap_sub_return.single_line:
                return f"""
  {wrap_sub_return.line1}
""".strip()
            else:
                return f"""
  {wrap_sub_return.line1}
    {wrap_sub_return.line2}
    {wrap_sub_return.line3}
    {wrap_sub_return.line4}
""".strip()
            

        def _get_ready_if_statements(self, config : Config):
            """
            Get the if statement for each group which decides its ready signal
            If there is not enough space in either queues, the signal is 0.
            Otherwise, the ready signal is 1.
            """
            load_empty_entries = NUM_EMPTY_ENTRIES_NAIVE_NAME(QueueType.LOAD)
            store_empty_entries = NUM_EMPTY_ENTRIES_NAIVE_NAME(QueueType.STORE)
            
            if_statements = ""
            for i in range(config.num_groups()):
                load_is_empty = f"{IS_EMPTY_NAME(QueueType.LOAD)}_i"
                store_is_empty = f"{IS_EMPTY_NAME(QueueType.STORE)}_i"

                group_init_ready = f"{GROUP_INIT_CHANNEL_NAME}_ready_{i}"

                num_loads = config.group_num_loads(i)
                num_stores = config.group_num_stores(i)

                if_statements += f"""
    -- Group {i} has:
    --      {num_loads} load(s)
    --      {num_stores} store(s)
    if 
      {load_is_empty} = '0' and {load_empty_entries}_int < {num_loads} 
        or
      {store_is_empty} = '0' and {store_empty_entries}_int < {num_stores}
    then
        {group_init_ready} <= '0';
    else 
        {group_init_ready} <= '1';
    end if;
""".removeprefix("\n")
            
            return if_statements.strip()
                

        def _get_output_assignments(config: Config):
            """
            The init ready signal is local, 
            since it is used to calculate the init transfer output.

            However, it is also used as an output to the dataflow circuit.

            This generates an assignment for the
            group init ready output for each group,
            and also ands the ready with the group init valid to create
            the group init transfer signal.
            """
            assignments = ""

            for i in range(config.num_groups()):
                init_ready = f"{GROUP_INIT_CHANNEL_NAME}_ready_{i}"
                init_valid = f"{GROUP_INIT_CHANNEL_NAME}_valid_{i}_i"
                init_transfer = f"{GROUP_INIT_TRANSFER_NAME}_{i}_o"

                assignments += f"""
  -- drive the ready output
  {init_ready}_o <= {init_ready};

  -- drive the transfer output
  {init_transfer} <= {init_valid} and {init_ready};

""".removeprefix("\n")
                
            return assignments.strip()
        
        
# Declarative local signal only used by the group handshaking unit
class NaiveNumEmptyEntries(Signal):
    """
    Bitwidth = N

    Number = 1

    Number of empty entries in a queue, naively calculated.
    Needs to be combined with isEmpty to calculate the real value.

    Same bitwidth as queue pointer.
    """

    def __init__(self, 
                    config : Config,
                    queue_type : QueueType,
                    ):

        Signal.__init__(
            self,
            base_name=NUM_EMPTY_ENTRIES_NAIVE_NAME(queue_type),
            size=Signal.Size(
                bitwidth=config.queue_idx_bitwidth(queue_type),
                number=1
            )
        )