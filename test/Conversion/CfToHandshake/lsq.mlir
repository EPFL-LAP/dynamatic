// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py
// RUN: dynamatic-opt --lower-cf-to-handshake --remove-operation-names %s --split-input-file | FileCheck %s

// CHECK-LABEL:   handshake.func @simpleOneGroupLSQ(
// CHECK-SAME:                                      %[[VAL_0:.*]]: memref<64xi32>, %[[VAL_1:.*]]: !handshake.control<>, %[[VAL_2:.*]]: !handshake.control<>, ...) -> (!handshake.channel<i32>, !handshake.control<>, !handshake.control<>) attributes {argNames = ["mem0", "mem0_start", "start"], resNames = ["out0", "mem0_end", "end"]} {
// CHECK:           %[[VAL_3:.*]]:2 = lsq{{\[}}%[[VAL_0]] : memref<64xi32>] (%[[VAL_1]], %[[VAL_2]], %[[VAL_4:.*]], %[[VAL_5:.*]], %[[VAL_6:.*]], %[[VAL_7:.*]], %[[VAL_8:.*]], %[[VAL_2]])  {groupSizes = [3 : i32]} : (!handshake.control<>, !handshake.control<>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.control<>) -> (!handshake.channel<i32>, !handshake.control<>)
// CHECK:           %[[VAL_9:.*]] = constant %[[VAL_2]] {handshake.bb = 0 : ui32, value = 0 : i32} : <>, <i32>
// CHECK:           %[[VAL_10:.*]] = constant %[[VAL_2]] {handshake.bb = 0 : ui32, value = 1 : i32} : <>, <i32>
// CHECK:           %[[VAL_11:.*]] = constant %[[VAL_2]] {handshake.bb = 0 : ui32, value = 2 : i32} : <>, <i32>
// CHECK:           %[[VAL_4]], %[[VAL_12:.*]] = load{{\[}}%[[VAL_9]]] %[[VAL_3]]#0 {handshake.bb = 0 : ui32} : <i32>, <i32>
// CHECK:           %[[VAL_5]], %[[VAL_6]] = store{{\[}}%[[VAL_10]]] %[[VAL_12]] {handshake.bb = 0 : ui32} : <i32>, <i32>
// CHECK:           %[[VAL_7]], %[[VAL_8]] = store{{\[}}%[[VAL_11]]] %[[VAL_12]] {handshake.bb = 0 : ui32} : <i32>, <i32>
// CHECK:           end {handshake.bb = 0 : ui32} %[[VAL_12]], %[[VAL_3]]#1, %[[VAL_2]] : <i32>, <>, <>
// CHECK:         }
func.func @simpleOneGroupLSQ(%mem: memref<64xi32>) -> i32 {
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %ldData1 = memref.load %mem[%c0] {handshake.mem_interface = #handshake.mem_interface<LSQ: 0>} : memref<64xi32>
  memref.store %ldData1, %mem[%c1] {handshake.mem_interface = #handshake.mem_interface<LSQ: 0>} : memref<64xi32>
  memref.store %ldData1, %mem[%c2] {handshake.mem_interface = #handshake.mem_interface<LSQ: 0>} : memref<64xi32>
  return %ldData1 : i32
}

// -----

// CHECK-LABEL:   handshake.func @simpleMultiGroupLSQ(
// CHECK-SAME:                                        %[[VAL_0:.*]]: memref<64xi32>, %[[VAL_1:.*]]: !handshake.control<>, %[[VAL_2:.*]]: !handshake.control<>, ...) -> (!handshake.channel<i32>, !handshake.control<>, !handshake.control<>) attributes {argNames = ["mem0", "mem0_start", "start"], resNames = ["out0", "mem0_end", "end"]} {
// CHECK:           %[[VAL_3:.*]]:3 = lsq{{\[}}%[[VAL_0]] : memref<64xi32>] (%[[VAL_1]], %[[VAL_2]], %[[VAL_4:.*]], %[[VAL_5:.*]], %[[VAL_6:.*]], %[[VAL_7:.*]], %[[VAL_8:.*]], %[[VAL_9:.*]], %[[VAL_10:.*]], %[[VAL_6]])  {groupSizes = [2 : i32, 2 : i32]} : (!handshake.control<>, !handshake.control<>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.control<>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.control<>) -> (!handshake.channel<i32>, !handshake.channel<i32>, !handshake.control<>)
// CHECK:           %[[VAL_11:.*]] = constant %[[VAL_2]] {handshake.bb = 0 : ui32, value = 0 : i32} : <>, <i32>
// CHECK:           %[[VAL_12:.*]] = constant %[[VAL_2]] {handshake.bb = 0 : ui32, value = 1 : i32} : <>, <i32>
// CHECK:           %[[VAL_13:.*]] = constant %[[VAL_2]] {handshake.bb = 0 : ui32, value = 2 : i32} : <>, <i32>
// CHECK:           %[[VAL_4]], %[[VAL_14:.*]] = load{{\[}}%[[VAL_11]]] %[[VAL_3]]#0 {handshake.bb = 0 : ui32} : <i32>, <i32>
// CHECK:           %[[VAL_5]], %[[VAL_15:.*]] = load{{\[}}%[[VAL_12]]] %[[VAL_3]]#1 {handshake.bb = 0 : ui32} : <i32>, <i32>
// CHECK:           %[[VAL_16:.*]] = br %[[VAL_14]] {handshake.bb = 0 : ui32} : <i32>
// CHECK:           %[[VAL_17:.*]] = br %[[VAL_15]] {handshake.bb = 0 : ui32} : <i32>
// CHECK:           %[[VAL_18:.*]] = br %[[VAL_12]] {handshake.bb = 0 : ui32} : <i32>
// CHECK:           %[[VAL_19:.*]] = br %[[VAL_13]] {handshake.bb = 0 : ui32} : <i32>
// CHECK:           %[[VAL_20:.*]] = br %[[VAL_2]] {handshake.bb = 0 : ui32} : <>
// CHECK:           %[[VAL_21:.*]] = merge %[[VAL_16]] {handshake.bb = 1 : ui32} : <i32>
// CHECK:           %[[VAL_22:.*]] = merge %[[VAL_17]] {handshake.bb = 1 : ui32} : <i32>
// CHECK:           %[[VAL_23:.*]] = merge %[[VAL_18]] {handshake.bb = 1 : ui32} : <i32>
// CHECK:           %[[VAL_24:.*]] = merge %[[VAL_19]] {handshake.bb = 1 : ui32} : <i32>
// CHECK:           %[[VAL_6]], %[[VAL_25:.*]] = control_merge %[[VAL_20]]  {handshake.bb = 1 : ui32} : [<>] to <>, <i1>
// CHECK:           %[[VAL_7]], %[[VAL_8]] = store{{\[}}%[[VAL_23]]] %[[VAL_21]] {handshake.bb = 1 : ui32} : <i32>, <i32>
// CHECK:           %[[VAL_9]], %[[VAL_10]] = store{{\[}}%[[VAL_24]]] %[[VAL_22]] {handshake.bb = 1 : ui32} : <i32>, <i32>
// CHECK:           end {handshake.bb = 1 : ui32} %[[VAL_21]], %[[VAL_3]]#2, %[[VAL_2]] : <i32>, <>, <>
// CHECK:         }
func.func @simpleMultiGroupLSQ(%mem: memref<64xi32>) -> i32 {
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %ldData1 = memref.load %mem[%c0] {handshake.mem_interface = #handshake.mem_interface<LSQ: 0>} : memref<64xi32>
  %ldData2 = memref.load %mem[%c1] {handshake.mem_interface = #handshake.mem_interface<LSQ: 0>} : memref<64xi32>
  cf.br ^bb1(%ldData1, %ldData2 : i32, i32)
^bb1(%stData1: i32, %stData2: i32):
  memref.store %stData1, %mem[%c1] {handshake.mem_interface = #handshake.mem_interface<LSQ: 1>} : memref<64xi32>
  memref.store %stData2, %mem[%c2] {handshake.mem_interface = #handshake.mem_interface<LSQ: 1>} : memref<64xi32>
  return %stData1 : i32
}

// -----

// CHECK-LABEL:   handshake.func @mixLSQAndMCLoads(
// CHECK-SAME:                                     %[[VAL_0:.*]]: memref<64xi32>, %[[VAL_1:.*]]: !handshake.control<>, %[[VAL_2:.*]]: !handshake.control<>, ...) -> (!handshake.channel<i32>, !handshake.control<>, !handshake.control<>) attributes {argNames = ["mem0", "mem0_start", "start"], resNames = ["out0", "mem0_end", "end"]} {
// CHECK:           %[[VAL_3:.*]]:3, %[[VAL_4:.*]] = mem_controller{{\[}}%[[VAL_0]] : memref<64xi32>] %[[VAL_1]] (%[[VAL_5:.*]], %[[VAL_6:.*]], %[[VAL_7:.*]]#2, %[[VAL_7]]#3, %[[VAL_7]]#4) %[[VAL_8:.*]] {connectedBlocks = [0 : i32, 1 : i32]} : (!handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>) -> (!handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>)
// CHECK:           %[[VAL_7]]:5 = lsq[MC] (%[[VAL_2]], %[[VAL_9:.*]], %[[VAL_8]], %[[VAL_10:.*]], %[[VAL_3]]#2)  {groupSizes = [1 : i32, 1 : i32]} : (!handshake.control<>, !handshake.channel<i32>, !handshake.control<>, !handshake.channel<i32>, !handshake.channel<i32>) -> (!handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>)
// CHECK:           %[[VAL_11:.*]] = constant %[[VAL_2]] {handshake.bb = 0 : ui32, value = 0 : i32} : <>, <i32>
// CHECK:           %[[VAL_12:.*]] = constant %[[VAL_2]] {handshake.bb = 0 : ui32, value = 1 : i32} : <>, <i32>
// CHECK:           %[[VAL_13:.*]] = constant %[[VAL_2]] {handshake.bb = 0 : ui32, value = 2 : i32} : <>, <i32>
// CHECK:           %[[VAL_9]], %[[VAL_14:.*]] = load{{\[}}%[[VAL_11]]] %[[VAL_7]]#0 {handshake.bb = 0 : ui32} : <i32>, <i32>
// CHECK:           %[[VAL_5]], %[[VAL_15:.*]] = load{{\[}}%[[VAL_12]]] %[[VAL_3]]#0 {handshake.bb = 0 : ui32} : <i32>, <i32>
// CHECK:           %[[VAL_16:.*]] = br %[[VAL_11]] {handshake.bb = 0 : ui32} : <i32>
// CHECK:           %[[VAL_17:.*]] = br %[[VAL_13]] {handshake.bb = 0 : ui32} : <i32>
// CHECK:           %[[VAL_18:.*]] = br %[[VAL_2]] {handshake.bb = 0 : ui32} : <>
// CHECK:           %[[VAL_19:.*]] = merge %[[VAL_16]] {handshake.bb = 1 : ui32} : <i32>
// CHECK:           %[[VAL_20:.*]] = merge %[[VAL_17]] {handshake.bb = 1 : ui32} : <i32>
// CHECK:           %[[VAL_8]], %[[VAL_21:.*]] = control_merge %[[VAL_18]]  {handshake.bb = 1 : ui32} : [<>] to <>, <i1>
// CHECK:           %[[VAL_10]], %[[VAL_22:.*]] = load{{\[}}%[[VAL_19]]] %[[VAL_7]]#1 {handshake.bb = 1 : ui32} : <i32>, <i32>
// CHECK:           %[[VAL_6]], %[[VAL_23:.*]] = load{{\[}}%[[VAL_20]]] %[[VAL_3]]#1 {handshake.bb = 1 : ui32} : <i32>, <i32>
// CHECK:           %[[VAL_24:.*]] = addi %[[VAL_22]], %[[VAL_23]] {handshake.bb = 1 : ui32} : <i32>
// CHECK:           end {handshake.bb = 1 : ui32} %[[VAL_24]], %[[VAL_4]], %[[VAL_2]] : <i32>, <>, <>
// CHECK:         }
func.func @mixLSQAndMCLoads(%mem: memref<64xi32>) -> i32 {
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  %ldData1 = memref.load %mem[%c0] {handshake.mem_interface = #handshake.mem_interface<LSQ: 0>} : memref<64xi32>
  %ldData2 = memref.load %mem[%c1] {handshake.mem_interface = #handshake.mem_interface<MC>} : memref<64xi32>
  cf.br ^bb1
^bb1:
  %ldData3 = memref.load %mem[%c0] {handshake.mem_interface = #handshake.mem_interface<LSQ: 1>} : memref<64xi32>
  %ldData4 = memref.load %mem[%c2] {handshake.mem_interface = #handshake.mem_interface<MC>} : memref<64xi32>
  %add = arith.addi %ldData3, %ldData4 : i32
  return %add : i32
}

// -----

// CHECK-LABEL:   handshake.func @mixLSQAndMCStores(
// CHECK-SAME:                                      %[[VAL_0:.*]]: memref<64xi32>, %[[VAL_1:.*]]: !handshake.channel<i32>, %[[VAL_2:.*]]: !handshake.control<>, %[[VAL_3:.*]]: !handshake.control<>, ...) -> (!handshake.channel<i32>, !handshake.control<>, !handshake.control<>) attributes {argNames = ["mem0", "in0", "mem0_start", "start"], resNames = ["out0", "mem0_end", "end"]} {
// CHECK:           %[[VAL_4:.*]], %[[VAL_5:.*]] = mem_controller{{\[}}%[[VAL_0]] : memref<64xi32>] %[[VAL_2]] (%[[VAL_6:.*]], %[[VAL_7:.*]], %[[VAL_8:.*]], %[[VAL_9:.*]], %[[VAL_10:.*]]#0, %[[VAL_10]]#1, %[[VAL_10]]#2) %[[VAL_11:.*]] {connectedBlocks = [0 : i32, 1 : i32]} : (!handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>) -> !handshake.channel<i32>
// CHECK:           %[[VAL_10]]:3 = lsq[MC] (%[[VAL_3]], %[[VAL_12:.*]], %[[VAL_13:.*]], %[[VAL_11]], %[[VAL_14:.*]], %[[VAL_15:.*]], %[[VAL_4]])  {groupSizes = [1 : i32, 1 : i32]} : (!handshake.control<>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.control<>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>) -> (!handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>)
// CHECK:           %[[VAL_6]] = constant %[[VAL_3]] {handshake.bb = 0 : ui32, value = 2 : i32} : <>, <i32>
// CHECK:           %[[VAL_16:.*]] = constant %[[VAL_3]] {handshake.bb = 0 : ui32, value = 0 : i32} : <>, <i32>
// CHECK:           %[[VAL_17:.*]] = constant %[[VAL_3]] {handshake.bb = 0 : ui32, value = 1 : i32} : <>, <i32>
// CHECK:           %[[VAL_18:.*]] = constant %[[VAL_3]] {handshake.bb = 0 : ui32, value = 2 : i32} : <>, <i32>
// CHECK:           %[[VAL_12]], %[[VAL_13]] = store{{\[}}%[[VAL_16]]] %[[VAL_1]] {handshake.bb = 0 : ui32} : <i32>, <i32>
// CHECK:           %[[VAL_7]], %[[VAL_8]] = store{{\[}}%[[VAL_17]]] %[[VAL_1]] {handshake.bb = 0 : ui32} : <i32>, <i32>
// CHECK:           %[[VAL_19:.*]] = br %[[VAL_1]] {handshake.bb = 0 : ui32} : <i32>
// CHECK:           %[[VAL_20:.*]] = br %[[VAL_18]] {handshake.bb = 0 : ui32} : <i32>
// CHECK:           %[[VAL_21:.*]] = br %[[VAL_3]] {handshake.bb = 0 : ui32} : <>
// CHECK:           %[[VAL_9]] = constant %[[VAL_11]] {handshake.bb = 1 : ui32, value = 1 : i32} : <>, <i32>
// CHECK:           %[[VAL_22:.*]] = merge %[[VAL_19]] {handshake.bb = 1 : ui32} : <i32>
// CHECK:           %[[VAL_23:.*]] = merge %[[VAL_20]] {handshake.bb = 1 : ui32} : <i32>
// CHECK:           %[[VAL_11]], %[[VAL_24:.*]] = control_merge %[[VAL_21]]  {handshake.bb = 1 : ui32} : [<>] to <>, <i1>
// CHECK:           %[[VAL_14]], %[[VAL_15]] = store{{\[}}%[[VAL_23]]] %[[VAL_22]] {handshake.bb = 1 : ui32} : <i32>, <i32>
// CHECK:           end {handshake.bb = 1 : ui32} %[[VAL_22]], %[[VAL_5]], %[[VAL_3]] : <i32>, <>, <>
// CHECK:         }
func.func @mixLSQAndMCStores(%mem: memref<64xi32>, %data : i32) -> i32 {
  %c0 = arith.constant 0 : index
  %c1 = arith.constant 1 : index
  %c2 = arith.constant 2 : index
  memref.store %data, %mem[%c0] {handshake.mem_interface = #handshake.mem_interface<LSQ: 0>} : memref<64xi32>
  memref.store %data, %mem[%c1] {handshake.mem_interface = #handshake.mem_interface<MC>} : memref<64xi32>
  cf.br ^bb1(%data : i32)
^bb1(%stData : i32):
  memref.store %stData, %mem[%c2] {handshake.mem_interface = #handshake.mem_interface<LSQ: 1>} : memref<64xi32>
  return %stData : i32
}

// -----

// CHECK-LABEL:   handshake.func @ifThenElseSameLSQGroup(
// CHECK-SAME:                                           %[[VAL_0:.*]]: memref<64xi32>, %[[VAL_1:.*]]: !handshake.channel<i32>, %[[VAL_2:.*]]: !handshake.control<>, %[[VAL_3:.*]]: !handshake.control<>, ...) -> (!handshake.channel<i32>, !handshake.control<>, !handshake.control<>) attributes {argNames = ["mem0", "in0", "mem0_start", "start"], resNames = ["out0", "mem0_end", "end"]} {
// CHECK:           %[[VAL_4:.*]]:3, %[[VAL_5:.*]] = mem_controller{{\[}}%[[VAL_0]] : memref<64xi32>] %[[VAL_2]] (%[[VAL_6:.*]], %[[VAL_7:.*]], %[[VAL_8:.*]], %[[VAL_9:.*]]#1, %[[VAL_9]]#2, %[[VAL_9]]#3) %[[VAL_10:.*]] {connectedBlocks = [1 : i32, 2 : i32, 3 : i32]} : (!handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>) -> (!handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>)
// CHECK:           %[[VAL_9]]:4 = lsq[MC] (%[[VAL_3]], %[[VAL_11:.*]], %[[VAL_12:.*]], %[[VAL_13:.*]], %[[VAL_4]]#2)  {groupSizes = [2 : i32]} : (!handshake.control<>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>) -> (!handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>, !handshake.channel<i32>)
// CHECK:           %[[VAL_14:.*]] = source {handshake.bb = 0 : ui32}
// CHECK:           %[[VAL_15:.*]] = constant %[[VAL_14]] {handshake.bb = 0 : ui32, value = 0 : i32} : <>, <i32>
// CHECK:           %[[VAL_11]], %[[VAL_16:.*]] = load{{\[}}%[[VAL_1]]] %[[VAL_9]]#0 {handshake.bb = 0 : ui32} : <i32>, <i32>
// CHECK:           %[[VAL_17:.*]] = cmpi eq, %[[VAL_16]], %[[VAL_15]] {handshake.bb = 0 : ui32} : <i32>
// CHECK:           %[[VAL_18:.*]], %[[VAL_19:.*]] = cond_br %[[VAL_17]], %[[VAL_1]] {handshake.bb = 0 : ui32} : <i1>, <i32>
// CHECK:           %[[VAL_20:.*]], %[[VAL_21:.*]] = cond_br %[[VAL_17]], %[[VAL_3]] {handshake.bb = 0 : ui32} : <i1>, <>
// CHECK:           %[[VAL_22:.*]] = merge %[[VAL_18]] {handshake.bb = 1 : ui32} : <i32>
// CHECK:           %[[VAL_23:.*]], %[[VAL_24:.*]] = control_merge %[[VAL_20]]  {handshake.bb = 1 : ui32} : [<>] to <>, <i1>
// CHECK:           %[[VAL_25:.*]] = source {handshake.bb = 1 : ui32}
// CHECK:           %[[VAL_26:.*]] = constant %[[VAL_25]] {handshake.bb = 1 : ui32, value = 1 : i32} : <>, <i32>
// CHECK:           %[[VAL_27:.*]] = addi %[[VAL_22]], %[[VAL_26]] {handshake.bb = 1 : ui32} : <i32>
// CHECK:           %[[VAL_6]], %[[VAL_28:.*]] = load{{\[}}%[[VAL_27]]] %[[VAL_4]]#0 {handshake.bb = 1 : ui32} : <i32>, <i32>
// CHECK:           %[[VAL_29:.*]] = br %[[VAL_28]] {handshake.bb = 1 : ui32} : <i32>
// CHECK:           %[[VAL_30:.*]] = br %[[VAL_22]] {handshake.bb = 1 : ui32} : <i32>
// CHECK:           %[[VAL_31:.*]] = br %[[VAL_23]] {handshake.bb = 1 : ui32} : <>
// CHECK:           %[[VAL_32:.*]] = merge %[[VAL_19]] {handshake.bb = 2 : ui32} : <i32>
// CHECK:           %[[VAL_33:.*]], %[[VAL_34:.*]] = control_merge %[[VAL_21]]  {handshake.bb = 2 : ui32} : [<>] to <>, <i1>
// CHECK:           %[[VAL_35:.*]] = source {handshake.bb = 2 : ui32}
// CHECK:           %[[VAL_36:.*]] = constant %[[VAL_35]] {handshake.bb = 2 : ui32, value = 1 : i32} : <>, <i32>
// CHECK:           %[[VAL_37:.*]] = addi %[[VAL_32]], %[[VAL_36]] {handshake.bb = 2 : ui32} : <i32>
// CHECK:           %[[VAL_7]], %[[VAL_38:.*]] = load{{\[}}%[[VAL_37]]] %[[VAL_4]]#1 {handshake.bb = 2 : ui32} : <i32>, <i32>
// CHECK:           %[[VAL_39:.*]] = br %[[VAL_38]] {handshake.bb = 2 : ui32} : <i32>
// CHECK:           %[[VAL_40:.*]] = br %[[VAL_32]] {handshake.bb = 2 : ui32} : <i32>
// CHECK:           %[[VAL_41:.*]] = br %[[VAL_33]] {handshake.bb = 2 : ui32} : <>
// CHECK:           %[[VAL_8]] = constant %[[VAL_10]] {handshake.bb = 3 : ui32, value = 1 : i32} : <>, <i32>
// CHECK:           %[[VAL_42:.*]] = mux %[[VAL_43:.*]] {{\[}}%[[VAL_29]], %[[VAL_39]]] {handshake.bb = 3 : ui32} : <i1>, [<i32>, <i32>] to <i32>
// CHECK:           %[[VAL_44:.*]] = mux %[[VAL_43]] {{\[}}%[[VAL_30]], %[[VAL_40]]] {handshake.bb = 3 : ui32} : <i1>, [<i32>, <i32>] to <i32>
// CHECK:           %[[VAL_10]], %[[VAL_43]] = control_merge %[[VAL_31]], %[[VAL_41]]  {handshake.bb = 3 : ui32} : [<>, <>] to <>, <i1>
// CHECK:           %[[VAL_12]], %[[VAL_13]] = store{{\[}}%[[VAL_44]]] %[[VAL_42]] {handshake.bb = 3 : ui32} : <i32>, <i32>
// CHECK:           end {handshake.bb = 3 : ui32} %[[VAL_42]], %[[VAL_5]], %[[VAL_3]] : <i32>, <>, <>
// CHECK:         }
func.func @ifThenElseSameLSQGroup(%mem: memref<64xi32>, %idx: index) -> i32 {
  %c0 = arith.constant 0 : i32
  %ldData = memref.load %mem[%idx] {handshake.mem_interface = #handshake.mem_interface<LSQ: 0>} : memref<64xi32>
  %isEq = arith.cmpi eq, %ldData, %c0 : i32
  cf.cond_br %isEq, ^bb1, ^bb2
^bb1:
  %c1 = arith.constant 1 : index
  %add1 = arith.addi %c1, %idx : index
  %ldData1 = memref.load %mem[%add1] {handshake.mem_interface = #handshake.mem_interface<MC>} : memref<64xi32>
  cf.br ^bb3(%ldData1 : i32)
^bb2:
  %c2 = arith.constant 1 : index
  %add2 = arith.addi %c2, %idx : index
  %ldData2 = memref.load %mem[%add2] {handshake.mem_interface = #handshake.mem_interface<MC>}: memref<64xi32>
  cf.br ^bb3(%ldData2 : i32)
^bb3(%stData : i32):
  memref.store %stData, %mem[%idx] {handshake.mem_interface = #handshake.mem_interface<LSQ: 0>} : memref<64xi32>
  return %stData : i32
}
