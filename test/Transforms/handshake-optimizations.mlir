// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// about what constitutes a good test! The CHECK should be
// minimized and named to reflect the test intent.

// The script is designed to make adding checks to
// a test case fast, it is *not* designed to be authoritative
// minimized and named to reflect the test intent.

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py
// RUN: dynamatic-opt --handshake-optimization %s --split-input-file | FileCheck %s


// CHECK-LABEL:   handshake.func @removeBranchMUXPair_simple(
// CHECK-SAME:                                               %[[VAL_0:.*]]: i32,
// CHECK-SAME:                                               %[[VAL_1:.*]]: i1,
// CHECK-SAME:                                               %[[VAL_2:.*]]: none, ...) -> i32 attributes {argNames = ["arg0", "arg1", "start"], resNames = ["out0"]} {
// CHECK:           %[[VAL_3:.*]]:2 = fork [2] %[[VAL_1]] : i1
// CHECK:           sink %[[VAL_3]]#0 : i1
// CHECK:           sink %[[VAL_3]]#1 : i1
// CHECK:           end %[[VAL_0]] : i32
// CHECK:         }
handshake.func @removeBranchMUXPair_simple(%arg0: i32, %arg1: i1, %start: none) -> i32 {
  %arg1_one, %arg1_two = fork [2] %arg1: i1
  %true, %false = cond_br %arg1_one , %arg0 : i32
  %result_mux= mux %arg1_two [%true, %false]: i1, i32
  end %result_mux : i32
}
// CHECK-LABEL:   handshake.func @removeBranchCMergePair_simple(
// CHECK-SAME:                                                  %[[VAL_0:.*]]: i32,
// CHECK-SAME:                                                  %[[VAL_1:.*]]: i1,
// CHECK-SAME:                                                  %[[VAL_2:.*]]: none, ...) -> (i32, index) attributes {argNames = ["arg0", "arg1", "start"], resNames = ["out0", "out1"]} {
// CHECK:           end %[[VAL_0]], %[[VAL_1]] : i32, i1
// CHECK:         }
handshake.func @removeBranchCMergePair_simple(%arg0: i32, %arg1: i1, %start: none) -> (i32, index) {
  %true, %false = cond_br %arg1, %arg0 : i32
  %result_cmerge, %index= control_merge %true, %false : i32, index
  end %result_cmerge, %index : i32, index
}
// CHECK-LABEL:   handshake.func @removeBranchMUXPair_doNot(
// CHECK-SAME:                                              %[[VAL_0:.*]]: i32,
// CHECK-SAME:                                              %[[VAL_1:.*]]: i1,
// CHECK-SAME:                                              %[[VAL_2:.*]]: none, ...) -> i32 attributes {argNames = ["arg0", "arg1", "start"], resNames = ["out0"]} {
// CHECK:           %[[VAL_3:.*]] = arith.constant 2 : i32
// CHECK:           %[[VAL_4:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_5:.*]]:2 = fork [2] %[[VAL_1]] : i1
// CHECK:           %[[VAL_6:.*]], %[[VAL_7:.*]] = cond_br %[[VAL_5]]#0, %[[VAL_0]] : i32
// CHECK:           %[[VAL_8:.*]] = arith.addi %[[VAL_7]], %[[VAL_4]] : i32
// CHECK:           %[[VAL_9:.*]] = arith.muli %[[VAL_6]], %[[VAL_3]] : i32
// CHECK:           %[[VAL_10:.*]] = mux %[[VAL_5]]#1 {{\[}}%[[VAL_9]], %[[VAL_8]]] : i1, i32
// CHECK:           end %[[VAL_10]] : i32
// CHECK:         }
handshake.func @removeBranchMUXPair_doNot(%arg0: i32, %arg1: i1, %start: none) -> i32 {
  %arg1_one, %arg1_two = fork [2] %arg1: i1
  %true, %false = cond_br %arg1_one, %arg0: i32
  %num_1 = arith.constant 1 : i32
  %num_2 = arith.constant 2 : i32
  %add = arith.addi %false, %num_1 : i32
  %mul = arith.muli %true, %num_2 : i32
  %result_mux= mux %arg1_two [%mul, %add] : i1, i32
  end %result_mux : i32
}
// CHECK-LABEL:   handshake.func @removeBranchCMergePair_doNot(
// CHECK-SAME:                                                 %[[VAL_0:.*]]: i32,
// CHECK-SAME:                                                 %[[VAL_1:.*]]: i1,
// CHECK-SAME:                                                 %[[VAL_2:.*]]: none, ...) -> (i32, index) attributes {argNames = ["arg0", "arg1", "start"], resNames = ["out0", "out1"]} {
// CHECK:           %[[VAL_3:.*]] = arith.constant 2 : i32
// CHECK:           %[[VAL_4:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_5:.*]], %[[VAL_6:.*]] = cond_br %[[VAL_1]], %[[VAL_0]] : i32
// CHECK:           %[[VAL_7:.*]] = arith.addi %[[VAL_6]], %[[VAL_4]] : i32
// CHECK:           %[[VAL_8:.*]] = arith.muli %[[VAL_5]], %[[VAL_3]] : i32
// CHECK:           %[[VAL_9:.*]], %[[VAL_10:.*]] = control_merge %[[VAL_8]], %[[VAL_7]] : i32, index
// CHECK:           end %[[VAL_9]], %[[VAL_10]] : i32, index
// CHECK:         }
handshake.func @removeBranchCMergePair_doNot(%arg0: i32, %arg1: i1, %start: none) -> (i32, index) {
  %true, %false = cond_br %arg1, %arg0: i32
  %num_1 = arith.constant 1 : i32
  %num_2 = arith.constant 2 : i32
  %add = arith.addi %false, %num_1 : i32
  %mul = arith.muli %true, %num_2 : i32
  %result_cmerge, %index= control_merge %mul, %add : i32, index
  end %result_cmerge, %index : i32, index
}
// CHECK-LABEL:   handshake.func @removeBranchMUXPair(
// CHECK-SAME:                                        %[[VAL_0:.*]]: i32,
// CHECK-SAME:                                        %[[VAL_1:.*]]: i1,
// CHECK-SAME:                                        %[[VAL_2:.*]]: i1,
// CHECK-SAME:                                        %[[VAL_3:.*]]: none, ...) -> i32 attributes {argNames = ["arg0", "arg1", "arg2", "start"], resNames = ["out0"]} {
// CHECK:           %[[VAL_4:.*]] = arith.constant 2 : i32
// CHECK:           %[[VAL_5:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_6:.*]]:2 = fork [2] %[[VAL_1]] : i1
// CHECK:           %[[VAL_7:.*]]:2 = fork [2] %[[VAL_2]] : i1
// CHECK:           sink %[[VAL_6]]#0 : i1
// CHECK:           sink %[[VAL_6]]#1 : i1
// CHECK:           %[[VAL_8:.*]], %[[VAL_9:.*]] = cond_br %[[VAL_7]]#0, %[[VAL_0]] : i32
// CHECK:           %[[VAL_10:.*]] = arith.addi %[[VAL_9]], %[[VAL_5]] : i32
// CHECK:           %[[VAL_11:.*]] = arith.muli %[[VAL_8]], %[[VAL_4]] : i32
// CHECK:           %[[VAL_12:.*]] = mux %[[VAL_7]]#1 {{\[}}%[[VAL_11]], %[[VAL_10]]] : i1, i32
// CHECK:           end %[[VAL_12]] : i32
// CHECK:         }
handshake.func @removeBranchMUXPair(%arg0: i32, %arg1: i1, %arg2: i1, %start: none) -> i32 {
  %arg1_one, %arg1_two = fork [2] %arg1: i1
  %arg2_one, %arg2_two = fork [2] %arg2: i1
  %true, %false = cond_br %arg1_one, %arg0 : i32
  %result_mux= mux %arg1_two [%true, %false]: i1, i32
  %true_2, %false_2 = cond_br %arg2_one, %result_mux : i32
  %num_1 = arith.constant 1 : i32
  %num_2 = arith.constant 2 : i32
  %add = arith.addi %false_2, %num_1 : i32
  %mul = arith.muli %true_2, %num_2 : i32
  %result_mux_2= mux %arg2_two [%mul, %add]  : i1, i32
  end %result_mux_2 : i32
}
// CHECK-LABEL:   handshake.func @removeBranchCMergePair(
// CHECK-SAME:                                           %[[VAL_0:.*]]: i32,
// CHECK-SAME:                                           %[[VAL_1:.*]]: i1,
// CHECK-SAME:                                           %[[VAL_2:.*]]: i1,
// CHECK-SAME:                                           %[[VAL_3:.*]]: none, ...) -> i32 attributes {argNames = ["arg0", "arg1", "arg2", "start"], resNames = ["out0"]} {
// CHECK:           %[[VAL_4:.*]] = arith.constant 2 : i32
// CHECK:           %[[VAL_5:.*]] = arith.constant 1 : i32
// CHECK:           %[[VAL_6:.*]], %[[VAL_7:.*]] = cond_br %[[VAL_2]], %[[VAL_0]] : i32
// CHECK:           %[[VAL_8:.*]] = arith.addi %[[VAL_7]], %[[VAL_5]] : i32
// CHECK:           %[[VAL_9:.*]] = arith.muli %[[VAL_6]], %[[VAL_4]] : i32
// CHECK:           %[[VAL_10:.*]], %[[VAL_11:.*]] = control_merge %[[VAL_9]], %[[VAL_8]] : i32, index
// CHECK:           end %[[VAL_10]] : i32
// CHECK:         }
handshake.func @removeBranchCMergePair(%arg0: i32, %arg1: i1, %arg2: i1, %start: none) -> i32 {
  %true, %false = cond_br %arg1, %arg0 : i32
  %result_cmerge, %index= control_merge %true, %false : i32, index
  %true_2, %false_2 = cond_br %arg2, %result_cmerge : i32
  %num_1 = arith.constant 1 : i32
  %num_2 = arith.constant 2 : i32
  %add = arith.addi %false_2, %num_1 : i32
  %mul = arith.muli %true_2, %num_2 : i32
  %result_cmerge_2, %index_2= control_merge %mul, %add : i32, index
  end %result_cmerge_2 : i32
}
// CHECK-LABEL:   handshake.func @removeBranchCMergePair_multiple(
// CHECK-SAME:                                                    %[[VAL_0:.*]]: i32,
// CHECK-SAME:                                                    %[[VAL_1:.*]]: i1,
// CHECK-SAME:                                                    %[[VAL_2:.*]]: i1,
// CHECK-SAME:                                                    %[[VAL_3:.*]]: none, ...) -> i32 attributes {argNames = ["arg0", "arg1", "arg2", "start"], resNames = ["out0"]} {
// CHECK:           end %[[VAL_0]] : i32
// CHECK:         }
handshake.func @removeBranchCMergePair_multiple(%arg0: i32, %arg1: i1, %arg2: i1, %start: none) -> i32 {
  %true, %false = cond_br %arg1, %arg0 : i32
  %true_2, %false_2 = cond_br %arg2, %true : i32
  %result_cmerge, %index= control_merge %true_2, %false_2 : i32, index
  %result_cmerge_2, %index_2= control_merge %result_cmerge, %false : i32, index
  end %result_cmerge_2 : i32
}
// CHECK-LABEL:   handshake.func @removeBranchMUXPair_multiple(
// CHECK-SAME:                                                 %[[VAL_0:.*]]: i32,
// CHECK-SAME:                                                 %[[VAL_1:.*]]: i1,
// CHECK-SAME:                                                 %[[VAL_2:.*]]: i1,
// CHECK-SAME:                                                 %[[VAL_3:.*]]: none, ...) -> i32 attributes {argNames = ["arg0", "arg1", "arg2", "start"], resNames = ["out0"]} {
// CHECK:           %[[VAL_4:.*]]:2 = fork [2] %[[VAL_1]] : i1
// CHECK:           %[[VAL_5:.*]]:2 = fork [2] %[[VAL_2]] : i1
// CHECK:           sink %[[VAL_4]]#0 : i1
// CHECK:           sink %[[VAL_5]]#0 : i1
// CHECK:           sink %[[VAL_5]]#1 : i1
// CHECK:           sink %[[VAL_4]]#1 : i1
// CHECK:           end %[[VAL_0]] : i32
// CHECK:         }
handshake.func @removeBranchMUXPair_multiple(%arg0: i32, %arg1: i1, %arg2: i1, %start: none) -> i32 {
  %arg1_one, %arg1_two = fork [2] %arg1: i1
  %arg2_one, %arg2_two = fork [2] %arg2: i1
  %true, %false = cond_br %arg1_one, %arg0 : i32
  %true_2, %false_2 = cond_br %arg2_one, %true : i32
  %result_mux= mux %arg2_two [%true_2, %false_2]: i1, i32
  %result_mux_2= mux %arg1_two [%result_mux, %false]: i1, i32
  end %result_mux_2 : i32
}

// test cases fot the second set of transformations

handshake.func @removeBranchMUXPairloop_simple_case1(%arg0: i32, %arg1: i1, %arg2: i1, %start: none) -> i32 {
  %result_mux= mux %arg1 [%true, %arg0]: i1, i32
  %true, %false = cond_br %arg2, %result_mux : i32
  end %false : i32
}

handshake.func @removeBranchMUXPairloop_simple_case2(%arg0: i32, %arg1: i1, %arg2: i1, %start: none) -> i32 {
  %result_mux= mux %arg1 [%arg0, %false]: i1, i32
  %true, %false = cond_br %arg2, %result_mux : i32
  end %true : i32
}

handshake.func @removeBranchMUXPairloop_simple_case3(%arg0: i32, %arg1: i1, %arg2: i1, %start: none) -> i32 {
  %result_mux= mux %arg1 [%arg0, %true]: i1, i32
  %true, %false = cond_br %arg2, %result_mux : i32
  end %false : i32
}

handshake.func @removeBranchMUXPairloop_simple_case4(%arg0: i32, %arg1: i1, %arg2: i1, %start: none) -> i32 {
  %result_mux= mux %arg1 [%false, %arg0]: i1, i32
  %true, %false = cond_br %arg2, %result_mux : i32
  end %true : i32
}

handshake.func @removeBranchMergePairloop_simple_case1(%arg0: i32, %arg1: i1, %start: none) -> i32 {
  %result_merge= merge %true, %arg0: i32
  %true, %false = cond_br %arg1, %result_merge : i32
  end %false : i32
}

handshake.func @removeBranchMergePairloop_simple_case2(%arg0: i32, %arg1: i1, %start: none) -> i32 {
  %result_merge= merge %arg0, %false: i32
  %true, %false = cond_br %arg1, %result_merge : i32
  end %true : i32
}

handshake.func @removeBranchMergePairloop_simple_case3(%arg0: i32, %arg1: i1, %start: none) -> i32 {
  %result_merge= merge %arg0, %true: i32
  %true, %false = cond_br %arg1, %result_merge : i32
  end %false : i32
}

handshake.func @removeBranchMergePairloop_simple_case4(%arg0: i32, %arg1: i1, %start: none) -> i32 {
  %result_merge= merge %false, %arg0: i32
  %true, %false = cond_br %arg1, %result_merge : i32
  end %true : i32
}

handshake.func @removeBranchMUXPairloop_doNot_case1(%arg0: i32, %arg1: i1, %arg2: i1, %start: none) -> i32 {
  %result_mux= mux %arg1 [%true, %arg0]: i1, i32
  %num_1 = arith.constant 1: i32
  %data_in= arith.addi %result_mux, %num_1: i32
  %true, %false = cond_br %arg2, %data_in : i32
  end %false : i32
}

handshake.func @removeBranchMUXPairloop_doNot_case2(%arg0: i32, %arg1: i1, %arg2: i1, %start: none) -> i32 {
  %result_mux= mux %arg1 [%data_in, %arg0]: i1, i32
  %true, %false = cond_br %arg2, %result_mux : i32
  %num_2 = arith.constant 2: i32
  %data_in= arith.muli %true, %num_2: i32
  end %false : i32
}

handshake.func @removeBranchMergePairloop_doNot_case1(%arg0: i32, %arg1: i1, %start: none) -> i32 {
  %result_merge= merge %true, %arg0: i32
  %num_1 = arith.constant 1: i32
  %data_in= arith.addi %result_merge, %num_1: i32
  %true, %false = cond_br %arg1, %data_in : i32
  end %false : i32
}

handshake.func @removeBranchMergePairloop_doNot_case2(%arg0: i32, %arg1: i1, %start: none) -> i32 {
  %result_merge= merge %arg0, %data_in: i32
  %true, %false = cond_br %arg1, %result_merge : i32
  %num_2 = arith.constant 2: i32
  %data_in= arith.muli %true, %num_2: i32
  end %false : i32
}

handshake.func @removeBranchMUXPairloop_multiple(%arg0: i32, %arg1: i1, %arg2: i1, %arg3: i1, %arg4: i1, %start: none) -> i32 {
  %result_mux_1= mux %arg1 [%true_2, %arg0]: i1, i32
  %result_mux_2= mux %arg2 [%true_1, %result_mux_1]: i1, i32
  %true_1, %false_1 = cond_br %arg3, %result_mux_2 : i32
  %true_2, %false_2 = cond_br %arg4, %false_1 : i32
  end %false_2 : i32
}



handshake.func @removeBranchMergePairloop_multiple(%arg0: i32, %arg1: i1, %arg2: i1, %start: none) -> i32 {
  %result_merge_1= merge %true_2, %arg0: i32
  %result_merge_2= merge %true_1, %result_merge_1: i32
  %true_1, %false_1 = cond_br %arg1, %result_merge_2 : i32
  %true_2, %false_2 = cond_br %arg2, %false_1 : i32
  end %false_2 : i32
}

handshake.func @removeBranchMUXPairloop_multiple_doNot(%arg0: i32, %arg1: i1, %arg2: i1, %arg3: i1, %arg4: i1, %start: none) -> i32 {
  %result_mux_1= mux %arg1 [%true_2, %arg0]: i1, i32
  %result_mux_2= mux %arg2 [%true_1, %result_mux_1]: i1, i32
  %true_1, %false_1 = cond_br %arg3, %result_mux_2 : i32
  %num_1 = arith.constant 1 : i32
  %data_in = arith.addi %num_1, %false_1 : i32
  %true_2, %false_2 = cond_br %arg4, %data_in : i32
  end %false_2 : i32
}

handshake.func @removeBranchMergePairloop_multiple_doNot(%arg0: i32, %arg1: i1, %arg2: i1, %start: none) -> i32 {
  %result_merge_1= merge %true_2, %arg0: i32
  %result_merge_2= merge %true_1, %result_merge_1: i32
  %true_1, %false_1 = cond_br %arg1, %result_merge_2 : i32
  %num_1 = arith.constant 1 : i32
  %data_in = arith.addi %num_1, %false_1 : i32
  %true_2, %false_2 = cond_br %arg2, %data_in : i32
  end %false_2 : i32
}

handshake.func @removeBoth(%arg0: i32, %arg1: i1, %arg2: i1, %arg3: i1, %start: none) -> i32 {
  %result_mux= mux %arg1 [%true_2, %arg0]: i1, i32
  %result_merge= merge %true_1, %result_mux: i32
  %true_1, %false_1 = cond_br %arg2, %result_merge : i32
  %true_2, %false_2 = cond_br %arg3, %false_1 : i32
  end %false_2 : i32
}

handshake.func @removeBoth_doNot(%arg0: i32, %arg1: i1, %arg2: i1, %arg3: i1, %start: none) -> i32 {
  %result_mux= mux %arg1 [%true_2, %arg0]: i1, i32
  %result_merge= merge %true_1, %result_mux: i32
  %true_1, %false_1 = cond_br %arg2, %result_merge : i32
  %num_2 = arith.constant 2: i32
  %data_in= arith.muli %true_1, %num_2: i32
  %true_2, %false_2 = cond_br %arg3, %data_in: i32
  end %false_2 : i32
}

handshake.func @exampleBranchMUXPairloop(%x: i32, %j: i32, %c1: i1, %c2: i1) -> i32 {
  %c1_one, %c1_two = fork [2] %c1 : i1
  %c2_one, %c2_two = fork [2] %c2 : i1
  %result_mux_1= mux %c1_one [%x, %false]: i1, i32
  %true, %false = cond_br %c1_two, %result_mux_1 : i32
  %result_mux_2= mux %c2_one [%true, %false_2]: i1, i32
  %result_mux_2one, %result_mux_2two = fork [2] %result_mux_2 : i32
  %true_2, %false_2 = cond_br %c2_two, %result_mux_2two : i32
  sink %true_2 : i32
  %sta = arith.addi %j, %result_mux_2one: i32  
  end %sta : i32
}


handshake.func @removeMUXBranchloop_fork_doNot(%arg0: i32, %arg1: i1, %arg2: i1, %start: none) -> i32 {
  %result_mux = mux %arg1 [%arg0, %false] : i1, i32
  %c1, %c2 = fork [2] %result_mux : i32  
  %num_2 = arith.constant 2: i32
  %answer = arith.muli %num_2, %c1 : i32
  %true, %false = cond_br %arg2, %answer : i32
  sink %true: i32
  end 
} 

handshake.func @removeMUXBranchloop_fork_doOne(%arg0: i32, %arg1: i1, %arg2: i1, %arg3: i1, %arg4: i1, %start: none) -> () {
  %result_mux_1 = mux %arg1 [%arg0, %false_2] : i1, i32
  %c1, %c2 = fork [2] %result_mux_1 : i32  
  %num_2 = arith.constant 2: i32
  %answer = arith.muli %num_2, %c1 : i32
  %result_mux_2 = mux %arg2 [%c2, %false_1] : i1, i32
  %true_1, %false_1 = cond_br %arg3, %result_mux_2 : i32
  %true_2, %false_2 = cond_br %arg4, %true_1 : i32
  sink %true_2: i32  
  end
} 