// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py
// RUN: dynamatic-opt --handshake-optimize-bitwidths %s --split-input-file | FileCheck %s

// CHECK-LABEL:   handshake.func @cmergeToMuxIndexOpt(
// CHECK-SAME:                                        %[[VAL_0:.*]]: i32, %[[VAL_1:.*]]: i32,
// CHECK-SAME:                                        %[[VAL_2:.*]]: none, ...) -> (i32, i32) attributes {argNames = ["arg0", "arg1", "start"], resNames = ["out0", "out1"]} {
// CHECK:           %[[VAL_3:.*]], %[[VAL_4:.*]] = control_merge %[[VAL_0]], %[[VAL_1]] : i32, i1
// CHECK:           %[[VAL_5:.*]] = mux %[[VAL_4]] {{\[}}%[[VAL_0]], %[[VAL_1]]] : i1, i32
// CHECK:           %[[VAL_6:.*]]:2 = d_return %[[VAL_3]], %[[VAL_5]] : i32, i32
// CHECK:           end %[[VAL_6]]#0, %[[VAL_6]]#1 : i32, i32
// CHECK:         }
handshake.func @cmergeToMuxIndexOpt(%arg0: i32, %arg1: i32, %start: none) -> (i32, i32) {
  %result, %index = control_merge %arg0, %arg1 : i32, i32
  %mux = mux %index [%arg0, %arg1] : i32, i32
  %returnVals:2 = d_return %result, %mux : i32, i32
  end %returnVals#0, %returnVals#1 : i32, i32
}

// -----

// CHECK-LABEL:   handshake.func @memAddrOpt(
// CHECK-SAME:                               %[[VAL_0:.*]]: memref<1000xi32>,
// CHECK-SAME:                               %[[VAL_1:.*]]: none, ...) -> i32 attributes {argNames = ["mem", "start"], resNames = ["out0"]} {
// CHECK:           %[[VAL_2:.*]], %[[VAL_3:.*]] = mem_controller{{\[}}%[[VAL_0]] : memref<1000xi32>] (%[[VAL_4:.*]], %[[VAL_5:.*]], %[[VAL_6:.*]], %[[VAL_7:.*]], %[[VAL_8:.*]], %[[VAL_9:.*]]) {accesses = {{\[\[}}#handshake<AccessType Load>], [#handshake<AccessType Store>, #handshake<AccessType Store>]], id = 0 : i32} : (i10, i32, i10, i32, i10, i32) -> (i32, none)
// CHECK:           %[[VAL_10:.*]] = constant %[[VAL_1]] {value = 0 : i8} : i8
// CHECK:           %[[VAL_11:.*]] = arith.extui %[[VAL_10]] : i8 to i10
// CHECK:           %[[VAL_12:.*]] = constant %[[VAL_1]] {value = 500 : i16} : i16
// CHECK:           %[[VAL_13:.*]] = arith.trunci %[[VAL_12]] : i16 to i10
// CHECK:           %[[VAL_14:.*]] = constant %[[VAL_1]] {value = 999 : i32} : i32
// CHECK:           %[[VAL_15:.*]] = arith.trunci %[[VAL_14]] : i32 to i10
// CHECK:           %[[VAL_16:.*]] = constant %[[VAL_1]] {value = 42 : i32} : i32
// CHECK:           %[[VAL_5]] = constant %[[VAL_1]] {value = 2 : i32} : i32
// CHECK:           %[[VAL_4]], %[[VAL_17:.*]] = d_load{{\[}}%[[VAL_11]]] %[[VAL_2]] : i10, i32
// CHECK:           %[[VAL_6]], %[[VAL_7]] = d_store{{\[}}%[[VAL_13]]] %[[VAL_16]] : i32, i10
// CHECK:           %[[VAL_8]], %[[VAL_9]] = d_store{{\[}}%[[VAL_15]]] %[[VAL_16]] : i32, i10
// CHECK:           %[[VAL_18:.*]] = d_return %[[VAL_17]] : i32
// CHECK:           end %[[VAL_18]], %[[VAL_3]] : i32, none
// CHECK:         }
handshake.func @memAddrOpt(%mem: memref<1000xi32>, %start: none) -> i32 {
  %ldData1, %done = mem_controller[%mem : memref<1000xi32>] (%ldAddr1, %ctrl1, %stAddr1, %stData1, %stAddr2, %stData2) {accesses = [[#handshake<AccessType Load>], [#handshake<AccessType Store>, #handshake<AccessType Store>]], id = 0 : i32} : (i32, i32, i32, i32, i32, i32) -> (i32, none)
  %addr1 = handshake.constant %start {value = 0 : i8} : i8
  %addr2 = handshake.constant %start {value = 500 : i16}: i16
  %addr3 = handshake.constant %start {value = 999 : i32}: i32
  %dataStore = handshake.constant %start {value = 42 : i32}: i32
  %ctrl1 = handshake.constant %start {value = 2 : i32}: i32
  %addr1Ext = arith.extui %addr1 : i8 to i32
  %addr2Ext = arith.extui %addr2 : i16 to i32
  %ldAddr1, %ldVal = d_load[%addr1Ext] %ldData1 : i32, i32
  %stAddr1, %stData1 = d_store[%addr2Ext] %dataStore : i32, i32
  %stAddr2, %stData2 = d_store[%addr3] %dataStore : i32, i32
  %returnVal = d_return %ldVal : i32
  end %returnVal, %done : i32, none
}
