
-- ==============================================================
-- Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC v2019.2.1 (64-bit)
-- Copyright 1986-2019 Xilinx, Inc. All Rights Reserved.
-- ==============================================================
Library ieee;
use ieee.std_logic_1164.all;

entity subf_vitis_hls_wrapper is
    port (
        clk   : in  std_logic;
        reset : in  std_logic;
        ce    : in  std_logic;
        din0  : in  std_logic_vector(32 - 1 downto 0);
        din1  : in  std_logic_vector(32 - 1 downto 0);
        dout  : out std_logic_vector(32 - 1 downto 0)
    );
end entity;

architecture arch of subf_vitis_hls_wrapper is
    --------------------- Local signals ------------------
    signal aclk      : std_logic;
    signal aclken    : std_logic;
    signal a_tvalid  : std_logic;
    signal a_tdata   : std_logic_vector(32 - 1 downto 0);
    signal b_tvalid  : std_logic;
    signal b_tdata   : std_logic_vector(32 - 1 downto 0);
    signal r_tvalid  : std_logic;
    signal r_tdata   : std_logic_vector(32 - 1  downto 0);
    signal din0_buf1 : std_logic_vector(32 - 1 downto 0);
    signal din1_buf1 : std_logic_vector(32 - 1 downto 0);
    signal ce_r      : std_logic;
    signal dout_i    : std_logic_vector(32 - 1 downto 0);
    signal dout_r    : std_logic_vector(32 - 1 downto 0);
begin
    --------------------- Instantiation -----------------
    subf_vitis_hls_single_precision_lat_8_u : entity work.subf_vitis_hls_single_precision_lat_8
    port map (
        aclk                 => aclk,
        aclken               => aclken,
        s_axis_a_tvalid      => a_tvalid,
        s_axis_a_tdata       => a_tdata,
        s_axis_b_tvalid      => b_tvalid,
        s_axis_b_tdata       => b_tdata,
        m_axis_result_tvalid => r_tvalid,
        m_axis_result_tdata  => r_tdata
    );

    --------------------- Assignment --------------------
    aclk     <= clk;
    aclken   <= ce_r;
    a_tvalid <= '1';
    a_tdata  <= din0_buf1;
    b_tvalid <= '1';
    b_tdata  <= din1_buf1;
    dout_i   <= r_tdata;

    --------------------- Input buffer ------------------
    process (clk) begin
        if clk'event and clk = '1' then
            if ce = '1' then
                din0_buf1 <= din0;
                din1_buf1 <= din1;
            end if;
        end if;
    end process;

    process (clk) begin
        if clk'event and clk = '1' then
            ce_r <= ce;
        end if;
    end process;

    process (clk) begin
        if clk'event and clk = '1' then
            if ce_r = '1' then
                dout_r <= dout_i;
            end if;
        end if;
    end process;

    dout <= dout_i when ce_r = '1' else dout_r;
end architecture;

-- ==============================================================
-- Generated by Vitis HLS v2024.2.2
-- Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
-- Copyright 2022-2025 Advanced Micro Devices, Inc. All Rights Reserved.
-- ==============================================================

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity sdiv_32ns_32ns_32_36_seq_1_divseq is
    port (
        clk      : in  std_logic;
        reset    : in  std_logic;
        ce       : in  std_logic;
        dividend : in  std_logic_vector(32 - 1 downto 0);
        divisor  : in  std_logic_vector(32 - 1 downto 0);
        sign_i   : in  std_logic_vector(1 downto 0);
        sign_o   : out std_logic_vector(1 downto 0);
        quot     : out std_logic_vector(32 - 1 downto 0);
        remd     : out std_logic_vector(32 - 1 downto 0));
end entity;

architecture arch of sdiv_32ns_32ns_32_36_seq_1_divseq is
    signal dividend0    : unsigned(32 - 1 downto 0);
    signal divisor0     : unsigned(32 - 1 downto 0);
    signal sign0        : unsigned(1 downto 0);
    signal dividend_reg : unsigned(32 - 1 downto 0);
    signal remd_reg     : unsigned(32 - 1 downto 0);
    signal comb_tmp     : unsigned(32 - 1 downto 0);
    signal cal_tmp      : unsigned(32 downto 0);
begin
    quot   <= std_logic_vector(resize(dividend_reg, 32));
    remd   <= std_logic_vector(resize(remd_reg, 32));
    sign_o <= std_logic_vector(sign0);

    process (clk)
    begin
        if rising_edge(clk) then
            dividend0 <= unsigned(dividend);
            divisor0  <= unsigned(divisor);
            sign0     <= unsigned(sign_i);
        end if;
    end process;

    comb_tmp <= remd_reg(32 - 2 downto 0) & dividend_reg(32 - 1);
    cal_tmp  <= ('0' & comb_tmp) - ('0' & divisor0);

    process (clk)
    begin
        if rising_edge(clk) then
            if ce = '1' then
                dividend_reg <= dividend_reg(32 - 2 downto 0) & (not cal_tmp(32));
                if cal_tmp(32) = '1' then
                    remd_reg <= comb_tmp;
                else
                    remd_reg <= cal_tmp(32 - 1 downto 0);
                end if;
            end if;
        end if;
    end process;
end architecture;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- ==============================================================
-- Generated by Vitis HLS v2024.2.2
-- Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
-- Copyright 2022-2025 Advanced Micro Devices, Inc. All Rights Reserved.
-- ==============================================================


entity divsi_vitis_hls_wrapper is
    port (
        clk         : in  STD_LOGIC;
        reset       : in  STD_LOGIC;
        ce          : in  STD_LOGIC;
        din0        : in  STD_LOGIC_VECTOR(32 - 1 downto 0);
        din1        : in  STD_LOGIC_VECTOR(32 - 1 downto 0);
        dout        : out STD_LOGIC_VECTOR(32 - 1 downto 0));
end entity;

architecture arch of divsi_vitis_hls_wrapper is
    signal dividend0  : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal divisor0   : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal dividend_u : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal divisor_u  : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal quot_u     : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal remd_u     : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal quot       : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal remd       : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal sign_i     : STD_LOGIC_VECTOR(1 downto 0);
    signal sign_o     : STD_LOGIC_VECTOR(1 downto 0);
begin
    sdiv_32ns_32ns_32_36_seq_1_divseq_u : entity work.sdiv_32ns_32ns_32_36_seq_1_divseq
        port map(
            clk         => clk,
            reset       => reset,
            ce          => ce,
            dividend    => dividend_u,
            divisor     => divisor_u,
            sign_i      => sign_i,
            sign_o      => sign_o,
            quot        => quot_u,
            remd        => remd_u);

    sign_i      <= (dividend0(32-1) xor divisor0(32-1)) & dividend0(32-1);
    dividend_u  <= STD_LOGIC_VECTOR(UNSIGNED(not dividend0) + 1) when dividend0(32-1) = '1' else dividend0;
    divisor_u   <= STD_LOGIC_VECTOR(UNSIGNED(not divisor0) + 1) when divisor0(32-1) = '1' else divisor0;

process (clk)
begin
    if (clk'event and clk = '1') then
        dividend0 <= din0;
        divisor0 <= din1;

        if (sign_o(1) = '1') then
            quot <= STD_LOGIC_VECTOR(UNSIGNED(not quot_u) + 1);
            remd <= STD_LOGIC_VECTOR(UNSIGNED(not remd_u) + 1);
        else
            quot <= quot_u;
            remd <= remd_u;
        end if;
    end if;
end process;

dout <= quot;

end architecture;


-- ==============================================================
-- Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC v2019.2.1 (64-bit)
-- Copyright 1986-2019 Xilinx, Inc. All Rights Reserved.
-- ==============================================================
Library ieee;
use ieee.std_logic_1164.all;

entity divui_vitis_hls_wrapper is
    port (
        clk   : in  std_logic;
        reset : in  std_logic;
        ce    : in  std_logic;
        din0  : in  std_logic_vector(32 - 1 downto 0);
        din1  : in  std_logic_vector(32 - 1 downto 0);
        dout  : out std_logic_vector(32 - 1 downto 0)
    );
end entity;

architecture arch of divui_vitis_hls_wrapper is
    component array_RAM_udiv_32ns_32ns_32_36_1 is
        generic (
        ID         : integer;
        NUM_STAGE  : integer;
        din0_TYPE : integer;
        din1_TYPE : integer;
        dout_TYPE : integer);
        port (
        clk   : in  std_logic;
        reset : in  std_logic;
        ce    : in  std_logic;
        din0  : in  std_logic_vector(din0_TYPE - 1 downto 0);
        din1  : in  std_logic_vector(din1_TYPE - 1 downto 0);
        dout  : out std_logic_vector(dout_TYPE - 1 downto 0));
    end component;
begin
    --------------------- Instantiation -----------------
  array_RAM_udiv_32ns_32ns_32_36_1_U1 : component array_RAM_udiv_32ns_32ns_32_36_1
    generic map(
      ID        => 1,
      NUM_STAGE => 36,
      din0_TYPE => 32,
      din1_TYPE => 32,
      dout_TYPE => 32)
    port map(
      clk   => clk,
      reset => reset,
      ce    => ce,
      din0  => din0,
      din1  => din1,
      dout  => dout
    );
end architecture;

-- ==============================================================
-- Generated by Vitis HLS v2024.2.2
-- Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
-- Copyright 2022-2025 Advanced Micro Devices, Inc. All Rights Reserved.
-- ==============================================================

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity remsi_vitis_hls_wrapper is
    port (
        clk         : in  STD_LOGIC;
        reset       : in  STD_LOGIC;
        ce          : in  STD_LOGIC;
        din0        : in  STD_LOGIC_VECTOR(32 - 1 downto 0);
        din1        : in  STD_LOGIC_VECTOR(32 - 1 downto 0);
        dout        : out STD_LOGIC_VECTOR(32 - 1 downto 0));
end entity;

architecture arch of divsi_vitis_hls_wrapper is
    component sdiv_32ns_32ns_32_36_seq_1_divseq is
        port (
            reset       : in  STD_LOGIC;
            clk         : in  STD_LOGIC;
            ce          : in  STD_LOGIC;
            dividend    : in  STD_LOGIC_VECTOR(32 - 1 downto 0);
            divisor     : in  STD_LOGIC_VECTOR(32 - 1 downto 0);
            sign_i      : in  STD_LOGIC_VECTOR(1 downto 0);
            sign_o      : out STD_LOGIC_VECTOR(1 downto 0);
            quot        : out STD_LOGIC_VECTOR(32 - 1 downto 0);
            remd        : out STD_LOGIC_VECTOR(32 - 1 downto 0));
    end component;

    signal dividend0  : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal divisor0   : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal dividend_u : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal divisor_u  : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal quot_u     : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal remd_u     : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal quot       : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal remd       : STD_LOGIC_VECTOR(32 - 1 downto 0);
    signal sign_i     : STD_LOGIC_VECTOR(1 downto 0);
    signal sign_o     : STD_LOGIC_VECTOR(1 downto 0);
begin
    sdiv_32ns_32ns_32_36_seq_1_divseq_u : entity work.sdiv_32ns_32ns_32_36_seq_1_divseq
        port map(
            clk         => clk,
            reset       => reset,
            ce          => ce,
            dividend    => dividend_u,
            divisor     => divisor_u,
            sign_i      => sign_i,
            sign_o      => sign_o,
            quot        => quot_u,
            remd        => remd_u);

    sign_i      <= (dividend0(32-1) xor divisor0(32-1)) & dividend0(32-1);
    dividend_u  <= STD_LOGIC_VECTOR(UNSIGNED(not dividend0) + 1) when dividend0(32-1) = '1' else dividend0;
    divisor_u   <= STD_LOGIC_VECTOR(UNSIGNED(not divisor0) + 1) when divisor0(32-1) = '1' else divisor0;

process (clk)
begin
    if (clk'event and clk = '1') then
        dividend0 <= din0;
        divisor0 <= din1;

        if (sign_o(1) = '1') then
            quot <= STD_LOGIC_VECTOR(UNSIGNED(not quot_u) + 1);
            remd <= STD_LOGIC_VECTOR(UNSIGNED(not remd_u) + 1);
        else
            quot <= quot_u;
            remd <= remd_u;
        end if;
    end if;
end process;

dout <= remd;

end architecture;
