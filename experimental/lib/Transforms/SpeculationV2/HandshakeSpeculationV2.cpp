#include "HandshakeSpeculationV2.h"
#include "JSONImporter.h"
#include "MaterializationUtil.h"
#include "dynamatic/Dialect/Handshake/HandshakeInterfaces.h"
#include "dynamatic/Dialect/Handshake/HandshakeOps.h"
#include "dynamatic/Support/CFG.h"
#include "dynamatic/Support/LLVM.h"
#include "mlir/IR/AsmState.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/Diagnostics.h"
#include "mlir/IR/Location.h"
#include "mlir/IR/OperationSupport.h"
#include "mlir/IR/Value.h"
#include "mlir/Support/LLVM.h"
#include "mlir/Support/LogicalResult.h"
#include "llvm/ADT/ArrayRef.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/Support/ErrorHandling.h"
#include <fstream>

using namespace llvm::sys;
using namespace mlir;
using namespace dynamatic;
using namespace dynamatic::handshake;
using namespace dynamatic::experimental;
using namespace dynamatic::experimental::speculationv2;

namespace dynamatic {
namespace experimental {
namespace speculationv2 {

// Implement the base class and auto-generated create functions.
// Must be called from the .cpp file to avoid multiple definitions
#define GEN_PASS_DEF_HANDSHAKESPECULATIONV2
#include "experimental/Transforms/Passes.h.inc"

} // namespace speculationv2
} // namespace experimental
} // namespace dynamatic

struct HandshakeSpeculationV2Pass
    : public dynamatic::experimental::speculationv2::impl::
          HandshakeSpeculationV2Base<HandshakeSpeculationV2Pass> {
  using HandshakeSpeculationV2Base<
      HandshakeSpeculationV2Pass>::HandshakeSpeculationV2Base;
  void runDynamaticPass() override;
};

static std::pair<Value, Value> getLoopContinueAndExit(FuncOp funcOp,
                                                      unsigned headBB) {
  auto muxOps = funcOp.getOps<MuxOp>();
  auto muxOp = llvm::find_if(
      muxOps, [&](MuxOp mux) { return getLogicBB(mux) == headBB; });
  assert(muxOp != muxOps.end());

  auto initOp = cast<InitOp>((*muxOp).getSelectOperand().getDefiningOp());
  Value loopContinue = getForkTop(initOp.getOperand());

  // loopExit is the inverse of loopContinue

  // If there is already a NotOp using loopContinue, returns its result
  auto loopContinueUsers = iterateOverPossiblyIndirectUsers(loopContinue);
  Operation **notOpOrNull = llvm::find_if(
      loopContinueUsers, [&](Operation *op) { return isa<NotOp>(op); });
  if (notOpOrNull != loopContinueUsers.end()) {
    return {loopContinue, (*notOpOrNull)->getResult(0)};
  }

  // If loopContinue is generated by a NotOp, returns its operand
  Operation *indirectDefiningOp = getIndirectDefiningOp(loopContinue);
  if (auto notOp = dyn_cast<NotOp>(indirectDefiningOp)) {
    return {loopContinue, getForkTop(notOp.getOperand())};
  }

  // Otherwise, create a new NotOp
  OpBuilder builder(funcOp->getContext());
  builder.setInsertionPointAfterValue(loopContinue);
  NotOp notOp = builder.create<NotOp>(builder.getUnknownLoc(), loopContinue);
  setBB(notOp, headBB);
  materializeValue(loopContinue);
  return {loopContinue, getForkTop(notOp.getResult())};
}

/// Returns if the circuit is eligible for MuxPasserSwap.
static bool isEligibleForMuxPasserSwap(MuxOp muxOp) {
  // Ensure the rewritten subcircuit structure.
  Operation *backedgeDefiningOp = muxOp.getDataOperands()[1].getDefiningOp();
  if (!isa<PasserOp>(backedgeDefiningOp))
    return false;
  auto passerOp = cast<PasserOp>(backedgeDefiningOp);

  Operation *selectorDefiningOp = muxOp.getSelectOperand().getDefiningOp();
  if (!isa<InitOp>(selectorDefiningOp))
    return false;
  auto initOp = cast<InitOp>(selectorDefiningOp);

  if (!equalsIndirectly(passerOp.getCtrl(), initOp.getOperand()))
    return false;

  // TODO: Verify token counts

  return true;
}

/// Performs the MuxPasserSwap, swapping the MuxOp and PasserOp, and updating
/// the select operand and control of the MuxOp and PasserOp.
/// Returns the PasserOp that was swapped.
static PasserOp performMuxPasserSwap(MuxOp muxOp) {
  OpBuilder builder(muxOp.getContext());
  builder.setInsertionPoint(muxOp);

  auto passerOp =
      dyn_cast<PasserOp>(muxOp.getDataOperands()[1].getDefiningOp());

  // Materialization is required for swapping
  assertMaterialization(passerOp.getResult());

  // Swap mux and passer
  muxOp.getDataOperandsMutable()[1].set(passerOp.getData());
  passerOp.getDataMutable()[0].set(muxOp.getResult());
  muxOp.getResult().replaceAllUsesExcept(passerOp.getResult(), passerOp);

  InitOp init = cast<InitOp>(muxOp.getSelectOperand().getDefiningOp());
  assertMaterialization(init.getOperand());
  // Add repeating inits
  SpecV2RepeatingInitOp ri1 = builder.create<SpecV2RepeatingInitOp>(
      muxOp->getLoc(), init.getOperand(), 1);
  inheritBB(init, ri1);
  init.getOperandMutable()[0].set(ri1.getResult());

  assertMaterialization(passerOp.getCtrl());
  SpecV2RepeatingInitOp ri2 = builder.create<SpecV2RepeatingInitOp>(
      muxOp->getLoc(), passerOp.getCtrl(), 1);
  inheritBB(passerOp, ri2);
  passerOp.getCtrlMutable()[0].set(ri2.getResult());

  // Materialize passer's result for further rewriting.
  materializeValue(passerOp.getResult());

  return passerOp;
}

static SpecV2RepeatingInitOp moveRepeatingInitsUp(Value fedValue) {
  fedValue = getForkTop(fedValue);
  materializeValue(fedValue);

  Operation *uniqueUser = getUniqueUser(fedValue);
  if (auto ri = dyn_cast<SpecV2RepeatingInitOp>(uniqueUser)) {
    // Single use. No need to move repeating inits.
    return ri;
  }

  OpBuilder builder(fedValue.getContext());
  builder.setInsertionPointAfterValue(fedValue);

  ForkOp fork = cast<ForkOp>(uniqueUser);

  auto newRI =
      builder.create<SpecV2RepeatingInitOp>(fedValue.getLoc(), fedValue, 1);
  inheritBB(fedValue.getDefiningOp(), newRI);
  fedValue.replaceAllUsesExcept(newRI.getResult(), newRI);

  for (auto res : fork->getResults()) {
    if (auto ri = dyn_cast<SpecV2RepeatingInitOp>(getUniqueUser(res))) {
      ri.getResult().replaceAllUsesWith(newRI.getResult());
      ri->erase();
    } else {
      res.replaceAllUsesWith(fedValue);
    }
  }

  fork->erase();

  materializeValue(fedValue);
  materializeValue(newRI.getResult());

  return newRI;
}

static Value moveRepeatingInitDown(SpecV2RepeatingInitOp ri) {
  OpBuilder builder(ri->getContext());

  materializeValue(ri);
  Operation *user = getUniqueUser(ri.getResult());
  ForkOp fork = cast<ForkOp>(user);
  builder.setInsertionPoint(fork);
  for (auto res : fork->getResults()) {
    SpecV2RepeatingInitOp newRI =
        builder.create<SpecV2RepeatingInitOp>(ri.getLoc(), res, 1);
    inheritBB(ri, newRI);
    res.replaceAllUsesExcept(newRI.getResult(), newRI);
  }

  Value riOperand = ri.getOperand();

  ri.getResult().replaceAllUsesWith(riOperand);
  ri->erase();

  // Possibly two forks are nested, so flatten them
  materializeValue(riOperand);

  return riOperand;
}

/// Returns if the value is driven by a SourceOp
static bool isSourced(Value value) {
  Operation *definingOp = value.getDefiningOp();
  if (!definingOp)
    return false;

  // Heuristic to stop the traversal earlier.
  if (isa<handshake::MuxOp>(definingOp))
    return false;

  if (isa<SourceOp>(value.getDefiningOp()))
    return true;

  // If all operands of the defining operation are sourced, the value is also
  // sourced.
  return llvm::all_of(value.getDefiningOp()->getOperands(),
                      [](Value v) { return isSourced(v); });
}

/// If op is LoadOp, excludes operands coming from MemoryControllerOp.
static llvm::SmallVector<Value> getEffectiveOperands(Operation *op) {
  if (auto loadOp = dyn_cast<handshake::LoadOp>(op)) {
    // For LoadOp, only the data result is effective for rewriting
    return {loadOp.getAddress()};
  }
  return llvm::to_vector(op->getOperands());
}

/// If op is LoadOp, excludes results going to MemoryControllerOp.
static llvm::SmallVector<Value> getEffectiveResults(Operation *op) {
  if (auto loadOp = dyn_cast<handshake::LoadOp>(op)) {
    // For LoadOp, only the data result is effective for rewriting
    return {loadOp.getDataResult()};
  }
  // Unlike the operands, to_vector doesn't work
  llvm::SmallVector<Value> results;
  for (OpResult result : op->getResults()) {
    results.push_back(result);
  }
  return results;
}

static LogicalResult movePassersDownPM(Operation *pmOp) {
  OpBuilder builder(pmOp->getContext());
  builder.setInsertionPoint(pmOp);

  Location loc = builder.getUnknownLoc();
  Value ctrl = nullptr;

  // Remove PasserOp from each effective operand of the PM unit.
  for (Value operand : getEffectiveOperands(pmOp)) {
    Operation *definingOp = operand.getDefiningOp();
    if (auto passer = dyn_cast<PasserOp>(definingOp)) {
      loc = passer->getLoc();
      ctrl = passer.getCtrl();

      // The operand must be materialized to perform the motion correctly.
      assertMaterialization(operand);

      // Remove the defining PasserOp operation.
      passer.getResult().replaceAllUsesWith(passer.getData());
      passer->erase();
    } else {
      // If the operand is sourced, it doesn't need to be defined by OpT.
      if (isSourced(operand))
        continue;
      return pmOp->emitError(
          "Expected all operands to be defined by the PasserOp");
    }
  }

  // Add new PasserOp for each effective result of the PM unit.
  for (Value result : getEffectiveResults(pmOp)) {
    assertMaterialization(result);

    PasserOp newPasser = builder.create<PasserOp>(loc, result, ctrl);
    inheritBB(pmOp, newPasser);

    result.replaceAllUsesExcept(newPasser.getResult(), newPasser);
  }

  return success();
}

/// Returns if the specified PasserOp is eligible for motion past a PM unit.
static bool isEligibleForPasserMotionOverPM(PasserOp passerOp) {
  Value passerControl = passerOp.getCtrl();

  Operation *targetOp = getUniqueUser(passerOp.getResult());

  // If the targetOp is not a PM unit, return false.
  if (!isa<ArithOpInterface, NotOp, ForkOp, LazyForkOp, BufferOp, LoadOp>(
          targetOp))
    return false;

  // Iterate over operands of the targetOp to decide the eligibility for
  // motion.
  for (Value operand : getEffectiveOperands(targetOp)) {
    if (auto passerOp = dyn_cast<PasserOp>(operand.getDefiningOp())) {
      // If this passerOp is controlled by different control from the specified
      // one, not eligible.
      if (!equalsIndirectly(passerControl, passerOp.getCtrl()))
        return false;
    } else if (!isSourced(operand)) {
      // Each operand must be defined by a passer, except when it is driven by a
      // source op.
      return false;
    }
  }

  return true;
}

/// Move the specified passer past a PM unit.
static void performPasserMotionPastPM(PasserOp passerOp,
                                      DenseSet<PasserOp> &frontiers) {
  Value passerControl = passerOp.getCtrl();
  OpBuilder builder(passerOp->getContext());
  builder.setInsertionPoint(passerOp);

  Operation *targetOp = getUniqueUser(passerOp.getResult());

  // Remove passers from the frontiers
  for (Value operand : getEffectiveOperands(targetOp)) {
    if (auto passerOp = dyn_cast<PasserOp>(operand.getDefiningOp())) {
      frontiers.erase(passerOp);
    }
  }

  // Perform the motion
  auto motionResult = movePassersDownPM(targetOp);

  if (failed(motionResult)) {
    targetOp->emitError("Failed to perform motion for PasserOp");
    llvm_unreachable("SpeculationV2 algorithm failed");
  }

  // Add new passers to the frontiers
  for (auto result : getEffectiveResults(targetOp)) {
    auto newPasser = cast<PasserOp>(getUniqueUser(result));
    frontiers.insert(newPasser);
    // Materialize the result of the new passer for further rewriting.
    materializeValue(newPasser.getResult());
  }

  materializeValue(passerControl);
}

static void movePassersUpFork(ForkOp fork) {
  Value forkTop = getForkTop(fork.getOperand());
  materializeValue(forkTop);
  Operation *uniqueUser = getUniqueUser(forkTop);
  if (!isa<ForkOp>(uniqueUser))
    return;

  fork = cast<ForkOp>(uniqueUser);

  OpBuilder builder(fork->getContext());
  builder.setInsertionPointAfterValue(forkTop);

  PasserOp newPasser = nullptr;

  for (auto res : fork->getResults()) {
    Operation *uniqueUser = getUniqueUser(res);
    if (auto passer = dyn_cast<PasserOp>(uniqueUser)) {
      if (newPasser == nullptr) {
        newPasser = builder.create<PasserOp>(passer.getLoc(), forkTop,
                                             passer.getCtrl());
        inheritBB(passer, newPasser);
      }
      passer.getResult().replaceAllUsesWith(newPasser.getResult());
      passer->erase();
    } else {
      res.replaceAllUsesWith(forkTop);
    }
  }

  materializeValue(forkTop);
  materializeValue(newPasser.getResult());
  materializeValue(newPasser.getCtrl());
}

/// Builds an interpolator op that uses the same value for both operands.
/// Returns the interpolator op.
static void introduceIdentInterpolator(PasserOp passer) {
  Value ctrl = passer.getCtrl();
  assertMaterialization(ctrl);
  ctrl = passer.getCtrl();

  OpBuilder builder(ctrl.getContext());
  builder.setInsertionPoint(ctrl.getDefiningOp());

  SpecV2InterpolatorOp interpolatorOp =
      builder.create<SpecV2InterpolatorOp>(ctrl.getLoc(), ctrl, ctrl);
  inheritBB(passer, interpolatorOp);

  ctrl.replaceAllUsesExcept(interpolatorOp.getResult(), interpolatorOp);
}

/// Returns if the bottom passer is eligible for the passer induction.
static bool isEligibleForPasserInduction(PasserOp bottomPasser) {
  // 1. Ensure the rewritten subcircuit structure.
  // The upstream unit of the bottom passer must be a passer.
  Operation *upstreamOp = bottomPasser.getData().getDefiningOp();
  if (!isa<PasserOp>(upstreamOp)) {
    llvm::errs() << "No upstream passer\n";
    return false;
  }
  auto topPasser = cast<PasserOp>(upstreamOp);

  Operation *bottomCtrlDefiningOp = bottomPasser.getCtrl().getDefiningOp();
  // The ctrl of the bottom passer must be generated by an interpolator.
  if (!isa<SpecV2InterpolatorOp>(bottomCtrlDefiningOp)) {
    llvm::errs() << "No interpolator\n";
    return false;
  }
  auto interpolator = cast<SpecV2InterpolatorOp>(bottomCtrlDefiningOp);

  Operation *topCtrlDefiningOp = topPasser.getCtrl().getDefiningOp();
  if (!isa<SpecV2RepeatingInitOp>(topCtrlDefiningOp)) {
    llvm::errs() << "No repeating init\n";
    return false;
  }
  auto ri = cast<SpecV2RepeatingInitOp>(topCtrlDefiningOp);

  // 2. Ensure the context

  if (!equalsIndirectly(interpolator.getLongOperand(), ri.getOperand())) {
    llvm::errs() << "Invalid longOperand of the interpolator";
    return false;
  }

  // TODO: Check REL

  return true;
}

/// Performs the passer induction.
/// The arguments are the bottom passer and the new interpolator. Other units
/// are referenced from the structure.
static void performPasserInduction(PasserOp bottomPasser) {
  auto interpolator =
      cast<SpecV2InterpolatorOp>(bottomPasser.getCtrl().getDefiningOp());
  auto topPasser = cast<PasserOp>(bottomPasser.getData().getDefiningOp());
  auto ri = cast<SpecV2RepeatingInitOp>(topPasser.getCtrl().getDefiningOp());
  interpolator.getLongOperandMutable()[0].set(ri.getResult());

  materializeValue(ri.getOperand());

  topPasser.getResult().replaceAllUsesWith(topPasser.getData());
  topPasser->erase();
}

static SpecV2InterpolatorOp moveInterpolatorsUp(Value shortOperand,
                                                Value longOperand) {
  shortOperand = getForkTop(shortOperand);

  materializeValue(shortOperand);

  Operation *shortOprdUniqueUser = getUniqueUser(shortOperand);

  if (!isa<ForkOp>(shortOprdUniqueUser)) {
    return cast<SpecV2InterpolatorOp>(shortOprdUniqueUser);
  }

  ForkOp shortOprdFork = cast<ForkOp>(shortOprdUniqueUser);

  OpBuilder builder(shortOperand.getContext());
  builder.setInsertionPointAfterValue(longOperand);

  SpecV2InterpolatorOp newInterpolator = builder.create<SpecV2InterpolatorOp>(
      shortOperand.getLoc(), shortOperand, longOperand);
  inheritBB(shortOprdFork, newInterpolator);

  for (auto res : shortOprdFork->getResults()) {
    bool rewritten = false;
    if (auto interpolator =
            dyn_cast<SpecV2InterpolatorOp>(getUniqueUser(res))) {
      if (interpolator.getShortOperand() == res &&
          equalsIndirectly(interpolator.getLongOperand(), longOperand)) {
        interpolator.getResult().replaceAllUsesWith(
            newInterpolator.getResult());
        interpolator->erase();
        rewritten = true;
      }
    }
    if (!rewritten) {
      res.replaceAllUsesWith(shortOperand);
    }
  }

  materializeValue(shortOperand);
  materializeValue(longOperand);
  materializeValue(newInterpolator.getResult());

  return newInterpolator;
}

/// Move the top (least recently added) repeating init and passer below the fork
/// as the preparation for the resolver insertion.
static void moveTopRIAndPasser(SpecV2InterpolatorOp interpolator, unsigned n) {
  auto topRI = cast<SpecV2RepeatingInitOp>(
      getIndirectDefiningOp(interpolator.getShortOperand()));
  auto oldPasserOp = cast<PasserOp>(topRI.getOperand().getDefiningOp());

  materializeValue(interpolator.getShortOperand());
  materializeValue(interpolator.getLongOperand());

  OpBuilder builder(topRI->getContext());

  moveRepeatingInitDown(topRI);

  Operation *fork = getUniqueUser(oldPasserOp.getResult());
  builder.setInsertionPoint(fork);
  // getUniqueUser(oldPasserOp.getResult())->dump();

  if (movePassersDownPM(fork).failed()) {
    llvm::errs() << "Failed to perform motion for PasserOp";
    llvm_unreachable("SpeculationV2 algorithm failed");
  }
}

/// Returns if the circuit is eligible for the introduction of the resolver.
static bool
isEligibleForResolverIntroduction(SpecV2InterpolatorOp interpolator) {
  // Ensure the structure
  Operation *shortOperandDefiningOp =
      interpolator.getShortOperand().getDefiningOp();
  if (!isa<SpecV2RepeatingInitOp>(shortOperandDefiningOp)) {
    llvm::errs() << "No repeating init\n";
    return false;
  }
  auto riOp = cast<SpecV2RepeatingInitOp>(shortOperandDefiningOp);

  Operation *riOpUpstream = riOp.getOperand().getDefiningOp();
  if (!isa<PasserOp>(riOpUpstream)) {
    llvm::errs() << "No passer\n";
    return false;
  }
  auto passerOp = cast<PasserOp>(riOpUpstream);

  if (!equalsIndirectly(passerOp.getCtrl(), interpolator.getResult())) {
    llvm::errs() << "Passer ctrl and interpolator result doesn't match\n";
    return false;
  }

  // TODO: Confirm the longOperand
  return true;
}

/// Introduces a spec resolver.
/// Returns the resolver result value.
static SpecV2ResolverOp
introduceSpecResolver(SpecV2InterpolatorOp interpolator) {
  auto riOp = cast<SpecV2RepeatingInitOp>(
      (interpolator.getShortOperand().getDefiningOp()));
  auto passerOp = cast<PasserOp>(riOp.getOperand().getDefiningOp());

  OpBuilder builder(interpolator->getContext());
  builder.setInsertionPoint(interpolator);

  auto resolverOp = builder.create<SpecV2ResolverOp>(
      interpolator.getLoc(), passerOp.getData(), interpolator.getLongOperand());
  inheritBB(interpolator, resolverOp);

  interpolator.getResult().replaceAllUsesWith(resolverOp.getResult());
  interpolator->erase();
  riOp->erase();
  passerOp->erase();
  return resolverOp;
}

/// Returns if the simplification of 3 passers is possible.
static bool isPasserSimplifiable(PasserOp ctrlDefiningPasser) {
  // Ensure the structure
  Operation *bottomOp = getUniqueUser(ctrlDefiningPasser.getResult());
  if (!isa<PasserOp>(bottomOp)) {
    llvm::errs() << "Bottom passer not found\n";
    return false;
  }
  auto bottomPasser = cast<PasserOp>(bottomOp);

  Operation *topOp = bottomPasser.getData().getDefiningOp();
  if (!isa<PasserOp>(topOp)) {
    llvm::errs() << "Top passer not found\n";
    return false;
  }
  auto topPasser = cast<PasserOp>(topOp);

  // Confirm the context
  if (!equalsIndirectly(ctrlDefiningPasser.getCtrl(), topPasser.getCtrl())) {
    llvm::errs() << "Ctrl mismatch\n";
    return false;
  }

  return true;
}

/// Simplify 3 passers into a single one.
static PasserOp simplifyPasser(PasserOp ctrlDefiningPasser) {
  OpBuilder builder(ctrlDefiningPasser.getContext());
  builder.setInsertionPoint(ctrlDefiningPasser);

  AndIOp andOp = builder.create<AndIOp>(builder.getUnknownLoc(),
                                        ctrlDefiningPasser.getData(),
                                        ctrlDefiningPasser.getCtrl());
  inheritBB(ctrlDefiningPasser, andOp);

  auto bottomPasser =
      cast<PasserOp>(getUniqueUser(ctrlDefiningPasser.getResult()));
  auto topPasser = cast<PasserOp>(bottomPasser.getData().getDefiningOp());

  bottomPasser.getCtrlMutable()[0].set(andOp.getResult());
  bottomPasser.getDataMutable()[0].set(topPasser.getData());

  topPasser->erase();
  ctrlDefiningPasser->erase();

  return bottomPasser;
}

static AndIOp moveAndIUp(Value lhs, Value rhs) {
  lhs = getForkTop(lhs);

  materializeValue(lhs);

  Operation *lhsUniqueUser = getUniqueUser(lhs);

  if (!isa<ForkOp>(lhsUniqueUser)) {
    return cast<AndIOp>(lhsUniqueUser);
  }

  ForkOp lhsFork = cast<ForkOp>(lhsUniqueUser);

  OpBuilder builder(lhs.getContext());
  builder.setInsertionPointAfterValue(rhs);

  AndIOp newAndI = builder.create<AndIOp>(lhs.getLoc(), lhs, rhs);
  inheritBB(lhsFork, newAndI);

  for (auto res : lhsFork->getResults()) {
    bool rewritten = false;
    if (auto andI = dyn_cast<AndIOp>(getUniqueUser(res))) {
      if (andI.getLhs() == res && equalsIndirectly(andI.getRhs(), rhs)) {
        andI.getResult().replaceAllUsesWith(newAndI.getResult());
        andI->erase();
        rewritten = true;
      }
    }
    if (!rewritten) {
      res.replaceAllUsesWith(lhs);
    }
  }

  materializeValue(lhs);
  materializeValue(rhs);
  materializeValue(newAndI.getResult());

  return newAndI;
}

/// Replace the repeating init chain with a merge to enable variable
/// speculation.
/// Returns the merge.
static MergeOp replaceRIChainWithMerge(SpecV2RepeatingInitOp bottomRI,
                                       unsigned n) {

  // Find the top repeating init in the chain.
  SpecV2RepeatingInitOp topRI = bottomRI;
  for (unsigned i = 1; i < n; i++) {
    topRI = cast<SpecV2RepeatingInitOp>(topRI.getOperand().getDefiningOp());
  }

  OpBuilder builder(bottomRI->getContext());
  builder.setInsertionPoint(bottomRI);
  Location specLoc = bottomRI.getLoc();
  unsigned bb = getLogicBB(bottomRI).value();

  // Generate the source and constant providing the continue token constantly.
  SourceOp conditionGenerator = builder.create<SourceOp>(specLoc);
  setBB(conditionGenerator, bb);
  conditionGenerator->setAttr("specv2_ignore_buffer",
                              builder.getBoolAttr(true));

  ConstantOp conditionConstant = builder.create<ConstantOp>(
      specLoc, IntegerAttr::get(builder.getIntegerType(1), 1),
      conditionGenerator.getResult());
  setBB(conditionConstant, bb);
  conditionConstant->setAttr("specv2_ignore_buffer", builder.getBoolAttr(true));

  // Buffer to prevent deadlock
  // Specify "buffer_as_sink" to hide the result edge from the buffering
  // algorithm.
  BufferOp specLoopContinueTehb = builder.create<BufferOp>(
      specLoc, topRI.getOperand(), 1, BufferType::ONE_SLOT_BREAK_R);
  setBB(specLoopContinueTehb, bb);
  specLoopContinueTehb->setAttr("specv2_buffer_as_sink",
                                builder.getBoolAttr(true));

  // Specify "buffer_as_source" to hide the input edges from the buffering
  // algorithm.
  MergeOp merge = builder.create<MergeOp>(
      specLoc, llvm::ArrayRef<Value>{specLoopContinueTehb.getResult(),
                                     conditionConstant.getResult()});
  setBB(merge, bb);
  merge->setAttr("specv2_buffer_as_source", builder.getBoolAttr(true));
  bottomRI.getResult().replaceAllUsesWith(merge.getResult());

  // Buffer after a merge is required, which is added in the buffering pass.

  // Remove repeating inits from the bottom of the chain.
  SpecV2RepeatingInitOp ri = bottomRI;
  SpecV2RepeatingInitOp nextRI;
  for (unsigned i = 0; i < n; i++) {
    if (i < n - 1) {
      nextRI = cast<SpecV2RepeatingInitOp>(ri.getOperand().getDefiningOp());
    }
    ri->erase();
    ri = nextRI;
  }

  materializeValue(merge.getResult());
  auto forkOp = cast<ForkOp>(*merge.getResult().getUsers().begin());
  builder.setInsertionPoint(forkOp);
  LazyForkOp lazyForkOp = builder.create<LazyForkOp>(
      forkOp.getLoc(), merge.getResult(), forkOp->getNumResults());
  inheritBB(forkOp, lazyForkOp);

  for (unsigned i = 0; i < forkOp->getNumResults(); i++) {
    forkOp->getResult(i).replaceAllUsesWith(lazyForkOp->getResult(i));
  }

  forkOp->erase();

  return merge;
}

static DenseMap<unsigned, unsigned> unifyBBs(ArrayRef<unsigned> loopBBs,
                                             FuncOp funcOp) {
  DenseMap<unsigned, unsigned> bbMap;
  unsigned minBB = *std::min_element(loopBBs.begin(), loopBBs.end());
  funcOp.walk([&](Operation *op) {
    auto bbOrNull = getLogicBB(op);
    if (!bbOrNull.has_value())
      return;

    unsigned bb = bbOrNull.value();
    if (!bbMap.contains(bb)) {
      if (std::find(loopBBs.begin(), loopBBs.end(), bb) != loopBBs.end()) {
        bbMap[bb] = minBB;
      } else {
        unsigned d = 0;
        for (auto loopBB : loopBBs) {
          if (loopBB == minBB)
            continue;
          if (loopBB < bb)
            d++;
        }
        bbMap[bb] = bb - d;
      }
    }

    setBB(op, bbMap[bb]);
  });

  return bbMap;
}

static void recalculateMCBlocks(FuncOp funcOp) {
  DenseSet<int32_t> bbs;
  OpBuilder builder(funcOp->getContext());

  for (auto mc :
       llvm::make_early_inc_range(funcOp.getOps<MemoryControllerOp>())) {
    bbs.clear();
    for (auto oprd : mc->getOperands()) {
      if (isa<ControlType>(oprd.getType()))
        continue;
      if (oprd.getDefiningOp()) {
        if (auto bbOrNull = getLogicBB(oprd.getDefiningOp())) {
          bbs.insert(bbOrNull.value());
        }
      }
    }
    for (auto res : mc->getResults()) {
      if (isa<ControlType>(res.getType()))
        continue;
      for (auto *user : res.getUsers()) {
        if (auto bbOrNull = getLogicBB(user)) {
          bbs.insert(bbOrNull.value());
        }
      }
    }
    auto i32Attr = builder.getI32ArrayAttr(llvm::to_vector(bbs));
    mc.setConnectedBlocksAttr(i32Attr);
  }
}

void HandshakeSpeculationV2Pass::runDynamaticPass() {
  // Parse json (jsonPath is a member variable handled by tablegen)
  auto bbOrFailure = readFromJSON(jsonPath);
  if (failed(bbOrFailure))
    return signalPassFailure();

  auto [loopBBs] = bbOrFailure.value();

  ModuleOp modOp = getOperation();

  // Support only one funcOp
  assert(std::distance(modOp.getOps<FuncOp>().begin(),
                       modOp.getOps<FuncOp>().end()) == 1 &&
         "Expected a single FuncOp in the module");

  FuncOp funcOp = *modOp.getOps<FuncOp>().begin();
  OpBuilder builder(funcOp->getContext());

  auto [loopContinue, loopExit] = getLoopContinueAndExit(funcOp, loopBBs[0]);

  DenseSet<PasserOp> frontiers;
  // n is a member variable handled by tablegen.
  // Storing repeating inits for post-processing.
  SmallVector<SpecV2RepeatingInitOp> repeatingInits(n);
  Value specLoopContinue = loopContinue;

  if (!disableInitialMotion) {
    for (Operation *op : iterateOverPossiblyIndirectUsers(loopContinue)) {
      if (auto passer = dyn_cast<PasserOp>(op)) {
        frontiers.insert(passer);
      }
    }

    bool frontiersUpdated;
    do {
      frontiersUpdated = false;
      for (auto passerOp : frontiers) {
        if (isEligibleForPasserMotionOverPM(passerOp)) {
          performPasserMotionPastPM(passerOp, frontiers);
          frontiersUpdated = true;
          // If frontiers are updated, the iterator is outdated.
          // Break and restart the loop.
          break;
        }
      }
      // If no frontiers were updated, we can stop.
    } while (frontiersUpdated);
  }

  // Repeatedly move passers past Muxes and PMSC.
  for (unsigned i = 0; i < n; i++) {
    frontiers.clear();

    // Perform MuxPasserSwap for each Mux
    for (auto muxOp :
         llvm::make_early_inc_range(funcOp.getOps<handshake::MuxOp>())) {
      if (getLogicBB(muxOp) != loopBBs.front())
        continue;

      if (!isEligibleForMuxPasserSwap(muxOp)) {
        muxOp.emitWarning(
            "MuxOp is not eligible for Passer swap, exiting the pass.");
        return signalPassFailure();
      }

      auto passerOp = performMuxPasserSwap(muxOp);

      // Add the moved passer to the frontiers
      frontiers.insert(passerOp);
    }

    auto newRI = moveRepeatingInitsUp(specLoopContinue);

    repeatingInits[i] = newRI;

    // Update SLC for the next iteration
    specLoopContinue = newRI.getResult();

    // Repeatedly move passers inside PMSC.
    bool frontiersUpdated;
    do {
      frontiersUpdated = false;
      for (auto passerOp : frontiers) {
        if (isEligibleForPasserMotionOverPM(passerOp)) {
          performPasserMotionPastPM(passerOp, frontiers);
          frontiersUpdated = true;
          // If frontiers are updated, the iterator is outdated.
          // Break and restart the loop.
          break;
        }
      }
      // If no frontiers were updated, we can stop.
    } while (frontiersUpdated);
  }

  if (n >= 1) {
    // Reduce the passer chain by introducing interpolator op and performing
    // induction.

    SmallVector<PasserOp> bottomPassers;

    // Introduce a trivial interpolators
    for (Operation *user :
         iterateOverPossiblyIndirectUsers(repeatingInits[0].getResult())) {
      if (auto passer = dyn_cast<PasserOp>(user)) {
        if (!isa<MuxOp>(getUniqueUser(passer.getResult()))) {
          introduceIdentInterpolator(passer);
          bottomPassers.push_back(passer);
        }
      }
    }

    // Perform induction
    for (unsigned i = 1; i < n; i++) {
      Value fedValue = moveRepeatingInitDown(repeatingInits[i]);

      // Perform the induction for each passer
      for (PasserOp bottomPasser : bottomPassers) {
        if (isEligibleForPasserInduction(bottomPasser)) {
          performPasserInduction(bottomPasser);
        } else {
          bottomPasser->emitError(
              "The bottomPasser is not eligible for induction");
          return signalPassFailure();
        }
      }

      repeatingInits[i] = moveRepeatingInitsUp(fedValue);
    }

    SpecV2InterpolatorOp interpolator = moveInterpolatorsUp(
        repeatingInits[0].getResult(), repeatingInits[n - 1].getResult());

    ForkOp fork = cast<ForkOp>(interpolator.getShortOperand().getDefiningOp());

    // Preparation for the resolver insertion
    moveTopRIAndPasser(interpolator, n);

    // Introduce the resolver
    if (!isEligibleForResolverIntroduction(interpolator)) {
      interpolator.emitError(
          "The circuit is not eligible for the resolver introduction");
      return signalPassFailure();
    }
    SpecV2ResolverOp resolver = introduceSpecResolver(interpolator);
    Value confirmSpec = resolver.getResult();

    Operation *shortDefiningOp =
        resolver.getGeneratedCondition().getDefiningOp();
    if (auto ri = dyn_cast<SpecV2RepeatingInitOp>(shortDefiningOp)) {
      // need to move up passer and ri
      movePassersUpFork(fork);
      moveRepeatingInitsUp(ri.getOperand());
    }

    // Simplify the exit passers.
    PasserOp lastBottomPasser = nullptr;
    for (Operation *user : iterateOverPossiblyIndirectUsers(loopExit)) {
      if (auto ctrlDefiningPasser = dyn_cast<PasserOp>(user)) {
        if (equalsIndirectly(ctrlDefiningPasser.getCtrl(), confirmSpec)) {
          if (isPasserSimplifiable(ctrlDefiningPasser)) {
            lastBottomPasser = simplifyPasser(ctrlDefiningPasser);
          } else {
            ctrlDefiningPasser->emitError(
                "Expected the exit passer to be simplifiable");
          }
        }
      }
    }

    Value specLoopExit = nullptr;
    if (lastBottomPasser != nullptr) {
      auto lastAndI = cast<AndIOp>(lastBottomPasser.getCtrl().getDefiningOp());
      auto newAndI = moveAndIUp(lastAndI.getLhs(), lastAndI.getRhs());
      specLoopExit = newAndI.getResult();
    }

    // variable is a member variable handled by tablegen.
    if (variable) {
      if (n < 2) {
        funcOp.emitError("Variable speculation requires n >= 2.");
        return signalPassFailure();
      }

      MergeOp merge = replaceRIChainWithMerge(repeatingInits[n - 1], n);

      // Optimize for buffering
      if (specLoopExit != nullptr) {
        auto buf = cast<BufferOp>(merge->getOperand(0).getDefiningOp());
        auto passer = cast<PasserOp>(buf.getOperand().getDefiningOp());
        passer.getCtrlMutable()[0].set(specLoopExit);
      }
    }
  }

  DenseMap<unsigned, unsigned> bbMap = unifyBBs(loopBBs, funcOp);
  // Convert bbMap to a json file
  std::ofstream csvFile(bbMapping);
  csvFile << "before,after\n";
  for (const auto &entry : bbMap) {
    csvFile << entry.first << "," << entry.second << "\n";
  }
  csvFile.close();

  recalculateMCBlocks(funcOp);
}
