//===- CreateWrappers.h - Generate Wrapper for SMV circuits -----*- C++ -*-===//
//
// Dynamatic is under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file implements a generator for wrappers for SMV circuits. It places
// sequence_generators at all the inputs and sinks at all the outputs.
// Additionally, properties and sequence constraints can be created.
//
//===----------------------------------------------------------------------===//

#ifndef DYNAMATIC_EXPERIMENTAL_ELASTIC_MITER_CREATE_FORMAL_TESTBENCH_H
#define DYNAMATIC_EXPERIMENTAL_ELASTIC_MITER_CREATE_FORMAL_TESTBENCH_H

#include "dynamatic/Support/LLVM.h"
#include "mlir/IR/MLIRContext.h"
#include "mlir/IR/Types.h"
#include <cstddef>
#include <filesystem>
#include <string>

using namespace mlir;

namespace dynamatic::experimental {

static constexpr llvm::StringLiteral
    SEQUENCE_GENERATOR_VALID_NAME("outs_valid");
static constexpr llvm::StringLiteral SEQUENCE_GENERATOR_DATA_NAME("outs");
static constexpr llvm::StringLiteral SINK_READY_NAME("ins_ready");

struct SmvTestbenchConfig {
  // Inputs of the model under test
  SmallVector<std::pair<std::string, Type>> arguments;
  // Outputs of the model under test
  SmallVector<std::pair<std::string, Type>> results;
  // Name of the model under test
  std::string modelSmvName;
  // Number of tokens generated by the sequence generators. If it is set to 0 a
  // generator capabale of creating an infinite number of tokens will be
  // created.
  size_t nrOfTokens = 0;
  // Determines if the sequence generator create exactly "nrOfTokens" tokens, or
  // can non-determinstically create fewer tokens.
  bool generateExactNrOfTokens = false;
  // Determines if the outputs are synchronized with a join or if they are
  // consumed by sinks
  bool syncOutput = false;
};

// Create a wrapper for the provided SMV file.
// nrOfTokens: Set the number of tokens
//   generated by the sequence generators. If it is set to 0 a generator
//   capabale of creating an infinite number of tokens will be created.
// exact: determines if the sequence generator create exactly "nrOfTokens"
//   tokens, or can non-determinstically create fewer tokens.
std::string createSmvFormalTestbench(const SmvTestbenchConfig &config);

// SMV module for a sequence generator with a finite number of tokens. The
// actual number of generated tokens is non-determinstically set between 0
// and (inclusive) max_tokens.
const std::string SMV_BOOL_INPUT = R"DELIM(
MODULE bool_input(nReady0, max_tokens)
  VAR outs : boolean;
  VAR counter : 0..31;
  FROZENVAR exact_tokens : 0..max_tokens;
  ASSIGN
    init(counter) := 0;
    next(counter) := case
      nReady0 & counter < exact_tokens : counter + 1;
      TRUE : counter;
    esac;

  -- make sure outs is persistent
  ASSIGN
    next(outs) := case
      outs_valid & !nReady0 : outs;
      TRUE : {TRUE, FALSE};
    esac;

  DEFINE outs_valid := counter < exact_tokens;)DELIM";

// SMV module for a sequence generator with a finite number of tokens. The
// number of generated tokens is exact_tokens.
const std::string SMV_BOOL_INPUT_EXACT = R"DELIM(
MODULE bool_input_exact(nReady0, exact_tokens)
  VAR outs : boolean;
  VAR counter : 0..31;
  ASSIGN
    init(counter) := 0;
    next(counter) := case
      nReady0 & counter < exact_tokens : counter + 1;
      TRUE : counter;
    esac;

  -- make sure outs is persistent
  ASSIGN
    next(outs) := case
      outs_valid & !nReady0 : outs;
      TRUE : {TRUE, FALSE};
    esac;

  DEFINE outs_valid := counter < exact_tokens;)DELIM";

// SMV module for a sequence generator with an infinite number of tokens
const std::string SMV_BOOL_INPUT_INF = R"DELIM(
MODULE bool_input_inf(nReady0)
    VAR outs : boolean;
    
    -- make sure outs is persistent
    ASSIGN
    next(outs) := case 
      outs_valid & !nReady0 : outs;
      TRUE : {TRUE, FALSE};
    esac;
    DEFINE outs_valid := TRUE;)DELIM";

// SMV module for a sequence generator with an infinite number of tokens
const std::string SMV_CTRL_INPUT_INF = R"DELIM(
MODULE ctrl_input_inf(nReady0)
  DEFINE outs_valid := TRUE;)DELIM";

// SMV module for a sequence generator with a finite number of tokens. The
// actual number of generated tokens is non-determinstically set between 0
// and (inclusive) max_tokens.
const std::string SMV_CTRL_INPUT = R"DELIM(
MODULE ctrl_input(nReady0, max_tokens)
  VAR counter : 0..31;
  FROZENVAR exact_tokens : 0..max_tokens;
  ASSIGN
    init(counter) := 0;
    next(counter) := case
      nReady0 & counter < exact_tokens : counter + 1;
      TRUE : counter;
    esac;

  DEFINE outs_valid := counter < exact_tokens;)DELIM";

// SMV module for a sequence generator with a finite number of tokens. The
// number of generated tokens is exact_tokens.
const std::string SMV_CTRL_INPUT_EXACT = R"DELIM(
MODULE ctrl_input_exact(nReady0, exact_tokens)
  VAR counter : 0..31;
  ASSIGN
    init(counter) := 0;
    next(counter) := case
      nReady0 & counter < exact_tokens : counter + 1;
      TRUE : counter;
    esac;

  DEFINE outs_valid := counter < exact_tokens;)DELIM";

const std::string SMV_SINK = R"DELIM(
MODULE sink(ins_valid)
  DEFINE ins_ready := TRUE;)DELIM";

} // namespace dynamatic::experimental
#endif // DYNAMATIC_EXPERIMENTAL_ELASTIC_MITER_CREATE_FORMAL_TESTBENCH_H