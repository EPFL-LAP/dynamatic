//===- CreateWrappers.h - Generate Wrapper for SMV circuits -----*- C++ -*-===//
//
// Dynamatic is under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file implements a generator for wrappers for SMV circuits. It places
// sequence_generators at all the inputs and sinks at all the outputs.
// Additionally, properties and sequence constraints can be created.
//
//===----------------------------------------------------------------------===//

#ifndef DYNAMATIC_EXPERIMENTAL_ELASTIC_MITER_CREATE_WRAPPERS_H
#define DYNAMATIC_EXPERIMENTAL_ELASTIC_MITER_CREATE_WRAPPERS_H

#include "FabricGeneration.h"
#include "dynamatic/Support/LLVM.h"
#include <cstddef>
#include <filesystem>
#include <string>

using namespace mlir;

namespace dynamatic::experimental {

// A struct to store a loop condition constraint. The number of tokens in the
// input with the index dataSequence is equivalent to the number of false tokens
// at the output with the index controlSequence. If lastFalse is set, the last
// token in the controlSequence needs to be false.
struct LoopSeqConstraint {
  size_t dataSequence;
  size_t controlSequence;
  size_t lastFalse;
};

// A struct to store a token limit constraint. The number of tokens at the input
// with index inputSequence can only be up to "limit" higher than the number of
// tokens at the ouput with the index outputSequence.
struct TokenLimitConstraint {
  size_t inputSequence;
  size_t outputSequence;
  size_t limit;
};

// A struct to store all the supported sequence constraints.
struct SequenceConstraints {
  SmallVector<std::string> seqLengthRelationConstraints;
  SmallVector<LoopSeqConstraint> loopSeqConstraints;
  SmallVector<TokenLimitConstraint> tokenLimitConstraints;
};

// Create a wrapper for the provided SMV file.
// includeProperties: If set also creates properties to check if all output
//   tokens are true, the output buffers are empty, and the input buffer have
//   the same number of tokens stored pairwise.
// nrOfTokens: Set the number of tokens
//   generated by the sequence generators. If it is set to 0 a generator
//   capabale of creating an infinite number of tokens will be created.
// exact: determines if the sequence generator create exactly "nrOfTokens"
//   tokens, or can non-determinstically create fewer tokens.
LogicalResult createWrapper(const std::filesystem::path &wrapperPath,
                            const ElasticMiterConfig &config,
                            const std::string &modelSmvName, size_t nrOfTokens,
                            bool includeProperties,
                            const SequenceConstraints &sequenceConstraints,
                            bool exact = false);

// SMV module for a sequence generator with a finite number of tokens. The
// actual number of generated tokens is non-determinstically set between 0 and
// (inclusive) max_tokens.
const std::string BOOL_INPUT =
    "#ifndef BOOL_INPUT\n"
    "#define BOOL_INPUT\n"
    "MODULE bool_input(nReady0, max_tokens)\n"
    "  VAR dataOut0 : boolean;\n"
    "  VAR counter : 0..31;\n"
    "  FROZENVAR exact_tokens : 0..max_tokens;\n"
    "  ASSIGN\n"
    "    init(counter) := 0;\n"
    "    next(counter) := case\n"
    "      nReady0 & counter < exact_tokens : counter + 1;\n"
    "      TRUE : counter;\n"
    "    esac;\n"
    "\n"
    "  -- make sure dataOut0 is persistent\n"
    "  ASSIGN\n"
    "    next(dataOut0) := case\n"
    "      valid0 & !nReady0 : dataOut0;\n"
    "      TRUE : {TRUE, FALSE};\n"
    "    esac;\n"
    "\n"
    "  DEFINE valid0 := counter < exact_tokens;\n"
    "#endif // BOOL_INPUT\n\n";

// SMV module for a sequence generator with a finite number of tokens. The
// number of generated tokens is exact_tokens.
const std::string BOOL_INPUT_EXACT =
    "#ifndef BOOL_INPUT_EXACT\n"
    "#define BOOL_INPUT_EXACT\n"
    "MODULE bool_input_exact(nReady0, exact_tokens)\n"
    "  VAR dataOut0 : boolean;\n"
    "  VAR counter : 0..31;\n"
    "  ASSIGN\n"
    "    init(counter) := 0;\n"
    "    next(counter) := case\n"
    "      nReady0 & counter < exact_tokens : counter + 1;\n"
    "      TRUE : counter;\n"
    "    esac;\n"
    "\n"
    "  -- make sure dataOut0 is persistent\n"
    "  ASSIGN\n"
    "    next(dataOut0) := case\n"
    "      valid0 & !nReady0 : dataOut0;\n"
    "      TRUE : {TRUE, FALSE};\n"
    "    esac;\n"
    "\n"
    "  DEFINE valid0 := counter < exact_tokens;\n"
    "#endif // BOOL_INPUT_EXACT\n\n";

// SMV module for a sequence generator with an infinite number of tokens
const std::string BOOL_INPUT_INF = "MODULE bool_input_inf(nReady0)\n"
                                   "    VAR dataOut0 : boolean;\n"
                                   "    \n"
                                   "    -- make sure dataOut0 is persistent\n"
                                   "    ASSIGN\n"
                                   "    next(dataOut0) := case \n"
                                   "      valid0 & !nReady0 : dataOut0;\n"
                                   "      TRUE : {TRUE, FALSE};\n"
                                   "    esac;\n"
                                   "    DEFINE valid0 := TRUE;\n\n";
} // namespace dynamatic::experimental
#endif