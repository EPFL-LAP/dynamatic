-- handshake_buffer_1 : buffer(['num_slots=2', 'bitwidth=0', 'buffer_type="FIFO_BREAK_DV"'])


MODULE handshake_buffer_1(ins_valid, outs_ready)
  VAR
    fifo : handshake_buffer_1__fifo(ins_valid, break_dv_ready);
    break_dv   : handshake_buffer_1__dv(fifo_valid, outs_ready);
    inner_counter : handshake_buffer_1__counter(ins_valid, ins_ready, outs_valid, outs_ready);

  DEFINE
    fifo_valid := fifo.outs_valid;
    break_dv_ready := break_dv.ins_ready;

    ins_ready := fifo.ins_ready;
    outs_valid := break_dv.outs_valid;
    

MODULE handshake_buffer_1__fifo(ins_valid, outs_ready)
    VAR 
    full : boolean;

    ASSIGN
    init(full) := FALSE;
    next(full) := (full <-> outs_ready) ? ins_valid : full;

    -- outputs
    DEFINE
    outs_valid := full | ins_valid;
    ins_ready := (!full) | outs_ready;


MODULE handshake_buffer_1__dv (ins_valid, outs_ready)
  VAR
  outs_valid_i : boolean;
  inner_counter : handshake_buffer_1__dv__counter(ins_valid, ins_ready, outs_valid, outs_ready);

  ASSIGN
  init(outs_valid_i) := FALSE;
  next(outs_valid_i) := ins_valid | (outs_valid_i & !outs_ready);

  -- output
  DEFINE
  ins_ready := !outs_valid_i | outs_ready;
  outs_valid := outs_valid_i;


MODULE handshake_buffer_1__dv__counter(ins_valid, ins_ready, outs_valid, outs_ready)
    VAR
    counter : 0..1;
    error : boolean;
    DEFINE
    write_en := ins_valid & ins_ready;
    read_en := outs_valid & outs_ready;
    ASSIGN
    init(counter) := 0;
    next(counter) := case
        write_en & read_en : counter;
        write_en & (counter < 1) : counter + 1;
        read_en & (counter > 0) : counter - 1;
        TRUE : counter;
    esac;
    init(error) := FALSE;
    next(error) := case
        write_en & read_en : error;
        write_en & (counter = 1) : TRUE;
        read_en & (counter = 0) : TRUE;
        TRUE : error;
    esac;



MODULE handshake_buffer_1__counter(ins_valid, ins_ready, outs_valid, outs_ready)
    VAR
    counter : 0..2;
    error : boolean;
    DEFINE
    write_en := ins_valid & ins_ready;
    read_en := outs_valid & outs_ready;
    ASSIGN
    init(counter) := 0;
    next(counter) := case
        write_en & read_en : counter;
        write_en & (counter < 2) : counter + 1;
        read_en & (counter > 0) : counter - 1;
        TRUE : counter;
    esac;
    init(error) := FALSE;
    next(error) := case
        write_en & read_en : error;
        write_en & (counter = 2) : TRUE;
        read_en & (counter = 0) : TRUE;
        TRUE : error;
    esac;


