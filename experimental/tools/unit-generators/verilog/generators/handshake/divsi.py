from generators.support.delay_buffer import generate_delay_buffer
from generators.handshake.join import generate_join


def generate_divsi(name, params):

    bitwidth = params["bitwidth"]
    latency = params["latency"]
    extra_signals = params.get("extra_signals", None)

    assert (latency == 36)

    join_name = name + "_join"
    join = generate_join(join_name, {"size": 2})

    delay_buffer_name = name + "_delay_buffer"
    delay_buffer = generate_delay_buffer(delay_buffer_name, {"size": 35})

    divsi_body = f"""
// Module of divsi
module {name} (
  // inputs
  input  clk,
  input  rst,
  input  [{bitwidth} - 1 : 0] lhs,
  input  lhs_valid,
  input  [{bitwidth} - 1 : 0] rhs,
  input  rhs_valid,
  input  result_ready,
  // outputs
  output [{bitwidth} - 1 : 0] result,
  output result_valid,
  output lhs_ready,
  output rhs_ready
);

  wire join_valid;
  wire done;

  // Instantiate the join node
  {join_name} join_inputs (
    .ins_valid  ({{rhs_valid, lhs_valid}}),
    .outs_ready (result_ready             ),
    .ins_ready  ({{rhs_ready, lhs_ready}}  ),
    .outs_valid (join_valid             )
  );

  sdiv_32ns_32ns_32_36_seq_1 #(
      .ID( 1 ),
      .NUM_STAGE( 36 ),
      .din0_WIDTH( 32 ),
      .din1_WIDTH( 32 ),
      .dout_WIDTH( 32 ))
  sdiv_32ns_32ns_32_36_seq_1_U1(
      .clk(clk),
      .reset(rst),
      .start(join_valid),
      .done(done),
      .din0(lhs),
      .din1(rhs),
      .ce(result_ready),
      .dout(result)
  );

  {delay_buffer_name} buff (
    .clk(clk),
    .rst(rst),
    .valid_in(join_valid),
    .ready_in(result_ready),
    .valid_out(result_valid)
  );

endmodule


// ==============================================================
// Generated by Vitis HLS v2024.2.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// Copyright 2022-2025 Advanced Micro Devices, Inc. All Rights Reserved.
// ==============================================================

module sdiv_32ns_32ns_32_36_seq_1_divseq
#(parameter
    in0_WIDTH = 32,
    in1_WIDTH = 32,
    out_WIDTH = 32
)
(
    input                       clk,
    input                       reset,
    input                       ce,
    input                       start,
    input       [in0_WIDTH-1:0] dividend,
    input       [in1_WIDTH-1:0] divisor,
    input       [1:0]           sign_i,
    output wire [1:0]           sign_o,
    output wire                 done,
    output wire [out_WIDTH-1:0] quot,
    output wire [out_WIDTH-1:0] remd
);

localparam cal_WIDTH = (in0_WIDTH > in1_WIDTH)? in0_WIDTH : in1_WIDTH;

//------------------------Local signal-------------------
reg     [in0_WIDTH-1:0] dividend0;
reg     [in1_WIDTH-1:0] divisor0;
reg     [1:0]           sign0;
reg     [in0_WIDTH-1:0] dividend_tmp;
reg     [in0_WIDTH-1:0] remd_tmp;
wire    [in0_WIDTH-1:0] dividend_tmp_gen;
wire    [in0_WIDTH-1:0] dividend_tmp_mux;
wire    [in0_WIDTH-1:0] remd_tmp_mux;
wire    [in0_WIDTH-1:0] comb_tmp;
wire    [cal_WIDTH:0]   cal_tmp;

//------------------------Body---------------------------
assign  quot   = dividend_tmp;
assign  remd   = remd_tmp;
assign  sign_o = sign0;

// dividend0, divisor0
always @(posedge clk)
begin
    if (start) begin
        dividend0 <= dividend;
        divisor0  <= divisor;
        sign0     <= sign_i;
    end
end

// One-Hot Register
// r_stage[0]=1:accept input; r_stage[in0_WIDTH]=1:done
reg     [in0_WIDTH:0]     r_stage;
assign done = r_stage[in0_WIDTH];
always @(posedge clk)
begin
    if (reset == 1'b1)
        r_stage[in0_WIDTH:0] <= {{in0_WIDTH{{1'b0}}}};
    else if (ce)
        r_stage[in0_WIDTH:0] <= {{r_stage[in0_WIDTH-1:0], start}};
end

// MUXs
assign  dividend_tmp_mux = r_stage[0]? dividend0 : dividend_tmp;
assign  remd_tmp_mux     = r_stage[0]? {{in0_WIDTH{{1'b0}}}} : remd_tmp;

assign  dividend_tmp_gen = (in0_WIDTH == 1) ? ~cal_tmp[cal_WIDTH] : {{dividend_tmp_mux[in0_WIDTH-2:0], ~cal_tmp[cal_WIDTH]}}; 
assign  comb_tmp         = (in0_WIDTH == 1) ? dividend_tmp_mux[0] : {{remd_tmp_mux[in0_WIDTH-2:0], dividend_tmp_mux[in0_WIDTH-1]}};

assign  cal_tmp  = {{1'b0, comb_tmp}} - {{1'b0, divisor0}};

always @(posedge clk)
begin
    if (ce) begin
        dividend_tmp <= dividend_tmp_gen;
        remd_tmp     <= cal_tmp[cal_WIDTH]? comb_tmp : cal_tmp[in0_WIDTH-1:0];
    end
end

endmodule

module sdiv_32ns_32ns_32_36_seq_1
#(parameter
        ID   = 1,
        NUM_STAGE   = 2,
        din0_WIDTH   = 32,
        din1_WIDTH   = 32,
        dout_WIDTH   = 32
)
(
        input                           clk,
        input                           reset,
        input                           ce,
        input                           start,
        output  reg                     done,
        input           [din0_WIDTH-1:0] din0,
        input           [din1_WIDTH-1:0] din1,
        output          [dout_WIDTH-1:0] dout
);
//------------------------Local signal-------------------
reg                       start0 = 'b0;
wire                      done0;
reg     [din0_WIDTH-1:0] dividend0;
reg     [din1_WIDTH-1:0] divisor0;
wire    [din0_WIDTH-1:0] dividend_u;
wire    [din1_WIDTH-1:0] divisor_u;
wire    [dout_WIDTH-1:0] quot_u;
wire    [dout_WIDTH-1:0] remd_u;
reg     [dout_WIDTH-1:0] quot;
reg     [dout_WIDTH-1:0] remd;
wire    [1:0]   sign_i;
wire    [1:0]   sign_o;
//------------------------Instantiation------------------
sdiv_32ns_32ns_32_36_seq_1_divseq #(
    .in0_WIDTH      ( din0_WIDTH ),
    .in1_WIDTH      ( din1_WIDTH ),
    .out_WIDTH      ( dout_WIDTH )
) sdiv_32ns_32ns_32_36_seq_1_divseq_u (
    .clk      ( clk ),
    .reset    ( reset ),
    .ce       ( ce ),
    .start    ( start0 ),
    .done     ( done0 ),
    .dividend ( dividend_u ),
    .divisor  ( divisor_u ),
    .sign_i   ( sign_i ),
    .sign_o   ( sign_o ),
    .quot     ( quot_u ),
    .remd     ( remd_u )
);
//------------------------Body---------------------------
assign sign_i     = {{dividend0[din0_WIDTH-1] ^ divisor0[din1_WIDTH-1], dividend0[din0_WIDTH-1]}};
assign dividend_u = dividend0[din0_WIDTH-1]? ~dividend0[din0_WIDTH-1:0] + 1'b1 :
                                              dividend0[din0_WIDTH-1:0];
assign divisor_u  = divisor0[din1_WIDTH-1]?  ~divisor0[din1_WIDTH-1:0] + 1'b1 :
                                              divisor0[din1_WIDTH-1:0];

always @(posedge clk)
begin
    if (ce) begin
        dividend0 <= din0;
        divisor0  <= din1;
        start0    <= start;
    end
end

always @(posedge clk)
begin
    done <= done0;
end

always @(posedge clk)
begin
    if (done0) begin
        if (sign_o[1])
            quot <= ~quot_u + 1'b1;
        else
            quot <= quot_u;
    end
end

always @(posedge clk)
begin
    if (done0) begin
        if (sign_o[0])
            remd <= ~remd_u + 1'b1;
        else
            remd <= remd_u;
    end
end

assign dout = quot;

endmodule
"""

    return join + delay_buffer + divsi_body
