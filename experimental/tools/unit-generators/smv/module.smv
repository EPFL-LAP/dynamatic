// test_module : memory_controller(['num_loads=5', 'num_stores=5', 'num_controls=5', 'port_types={"ldData":"!handshake.channel<i16>","ldAddr":"!handshake.channel<i16>"}'])


MODULE test_module(memStart_valid, memEnd_ready, ctrlEnd_valid, ctrl_0, ctrl_0_valid, ctrl_1, ctrl_1_valid, ctrl_2, ctrl_2_valid, ctrl_3, ctrl_3_valid, ctrl_4, ctrl_4_valid,
  ldAddr_0, ldAddr_0_valid, ldAddr_1, ldAddr_1_valid, ldAddr_2, ldAddr_2_valid, ldAddr_3, ldAddr_3_valid, ldAddr_4, ldAddr_4_valid, ldData_0_ready, ldData_1_ready, ldData_2_ready, ldData_3_ready, ldData_4_ready,
  stAddr_0, stAddr_0_valid, stAddr_1, stAddr_1_valid, stAddr_2, stAddr_2_valid, stAddr_3, stAddr_3_valid, stAddr_4, stAddr_4_valid, stData_0, stData_0_valid, stData_1, stData_1_valid, stData_2, stData_2_valid, stData_3, stData_3_valid, stData_4, stData_4_valid, loadData)

  VAR
  inner_mc_loadless : test_module__mc_loadless(memStart_valid, memEnd_ready, ctrlEnd_valid, ctrl_0, ctrl_0_valid, ctrl_1, ctrl_1_valid, ctrl_2, ctrl_2_valid, ctrl_3, ctrl_3_valid, ctrl_4, ctrl_4_valid,
    stAddr_0, stAddr_0_valid, stAddr_1, stAddr_1_valid, stAddr_2, stAddr_2_valid, stAddr_3, stAddr_3_valid, stAddr_4, stAddr_4_valid, stData_0, stData_0_valid, stData_1, stData_1_valid, stData_2, stData_2_valid, stData_3, stData_3_valid, stData_4, stData_4_valid, loadData);
  inner_arbiter : test_module__read_memory_arbiter(ldAddr_0_valid, ldAddr_1_valid, ldAddr_2_valid, ldAddr_3_valid, ldAddr_4_valid, ldAddr_0, ldAddr_1, ldAddr_2, ldAddr_3, ldAddr_4,
    ldData_0_ready, ldData_1_ready, ldData_2_ready, ldData_3_ready, ldData_4_ready, ldData_0, ldData_1, ldData_2, ldData_3, ldData_4, loadData);

  // outputs
  DEFINE
  memStart_ready := inner_mc_loadless.memStart_ready;
  memEnd_valid := inner_mc_loadless.memEnd_valid;
  ctrlEnd_ready := inner_mc_loadless.ctrlEnd_ready;

  ctrl_0_ready := inner_mc_loadless.ctrl_0_ready;
  ctrl_1_ready := inner_mc_loadless.ctrl_1_ready;
  ctrl_2_ready := inner_mc_loadless.ctrl_2_ready;
  ctrl_3_ready := inner_mc_loadless.ctrl_3_ready;
  ctrl_4_ready := inner_mc_loadless.ctrl_4_ready;

  ldAddr_0_ready := inner_arbiter.ready_0;
  ldAddr_1_ready := inner_arbiter.ready_1;
  ldAddr_2_ready := inner_arbiter.ready_2;
  ldAddr_3_ready := inner_arbiter.ready_3;
  ldAddr_4_ready := inner_arbiter.ready_4;

  ldData_0 := inner_arbiter.data_out_0;
  ldData_1 := inner_arbiter.data_out_1;
  ldData_2 := inner_arbiter.data_out_2;
  ldData_3 := inner_arbiter.data_out_3;
  ldData_4 := inner_arbiter.data_out_4;

  ldData_0_valid := inner_arbiter.valid_0;
  ldData_1_valid := inner_arbiter.valid_1;
  ldData_2_valid := inner_arbiter.valid_2;
  ldData_3_valid := inner_arbiter.valid_3;
  ldData_4_valid := inner_arbiter.valid_4;
  
  stAddr_0_ready := inner_mc_loadless.ready_0;
  stAddr_1_ready := inner_mc_loadless.ready_1;
  stAddr_2_ready := inner_mc_loadless.ready_2;
  stAddr_3_ready := inner_mc_loadless.ready_3;
  stAddr_4_ready := inner_mc_loadless.ready_4;

  stData_0_ready := inner_mc_loadless.ready_0;
  stData_1_ready := inner_mc_loadless.ready_1;
  stData_2_ready := inner_mc_loadless.ready_2;
  stData_3_ready := inner_mc_loadless.ready_3;
  stData_4_ready := inner_mc_loadless.ready_4;

  loadEn := inner_arbiter.read_enable;
  loadAddr := inner_arbiter.read_address;
  storeEn := inner_mc_loadless.write_enable;
  storeAddr := inner_mc_loadless.write_address;
  storeData := inner_mc_loadless.data_to_memory;

  
MODULE test_module__mc_loadless(memStart_valid, memEnd_ready, ctrlEnd_valid, ctrl_0, ctrl_0_valid, ctrl_1, ctrl_1_valid, ctrl_2, ctrl_2_valid, ctrl_3, ctrl_3_valid, ctrl_4, ctrl_4_valid, 
  stAddr_0, stAddr_0_valid, stAddr_1, stAddr_1_valid, stAddr_2, stAddr_2_valid, stAddr_3, stAddr_3_valid, stAddr_4, stAddr_4_valid, stData_0, stData_0_valid, stData_1, stData_1_valid, stData_2, stData_2_valid, stData_3, stData_3_valid, stData_4, stData_4_valid, loadData)

  VAR
  inner_arbiter : test_module__mc_loadless__write_memory_arbiter(stAddr_0_valid & stData_0_valid, stAddr_1_valid & stData_1_valid, stAddr_2_valid & stData_2_valid, stAddr_3_valid & stData_3_valid, stAddr_4_valid & stData_4_valid,
    stAddr_0, stAddr_1, stAddr_2, stAddr_3, stAddr_4, stData_0, stData_1, stData_2, stData_3, stData_4, TRUE, TRUE, TRUE, TRUE, TRUE);
  inner_mc_control : test_module__mc_loadless__mc_control(memStart_valid, memEnd_ready, ctrlEnd_valid, all_requests_done);
  remainingStores : integer;

  ASSIGN
  init(remainingStores) := 0;
  next(remainingStores) := case
    ctrl_0_valid = TRUE : remainingStores + toint(ctrl_0) - stores_done;
    ctrl_1_valid = TRUE : remainingStores + toint(ctrl_1) - stores_done;
    ctrl_2_valid = TRUE : remainingStores + toint(ctrl_2) - stores_done;
    ctrl_3_valid = TRUE : remainingStores + toint(ctrl_3) - stores_done;
    ctrl_4_valid = TRUE : remainingStores + toint(ctrl_4) - stores_done;
    TRUE : remainingStores - stores_done;
  esac;

  DEFINE
  stores_done := storeEn ? 1 : 0;
  all_requests_done := (remainingStores = 0) & (ctrl_0_valid = FALSE) & (ctrl_1_valid = FALSE) & (ctrl_2_valid = FALSE) & (ctrl_3_valid = FALSE) & (ctrl_4_valid = FALSE);

  // output
  DEFINE
  memStart_ready := inner_mc_control.memStart_ready;
  memEnd_valid := inner_mc_control.memEnd_valid;
  ctrlEnd_ready := inner_mc_control.ctrlEnd_ready;

  ctrl_0_ready := TRUE;
  ctrl_1_ready := TRUE;
  ctrl_2_ready := TRUE;
  ctrl_3_ready := TRUE;
  ctrl_4_ready := TRUE;

  stAddr_0_ready := inner_arbiter.ready_0;
  stAddr_1_ready := inner_arbiter.ready_1;
  stAddr_2_ready := inner_arbiter.ready_2;
  stAddr_3_ready := inner_arbiter.ready_3;
  stAddr_4_ready := inner_arbiter.ready_4;

  stData_0_ready := inner_arbiter.ready_0;
  stData_1_ready := inner_arbiter.ready_1;
  stData_2_ready := inner_arbiter.ready_2;
  stData_3_ready := inner_arbiter.ready_3;
  stData_4_ready := inner_arbiter.ready_4;

  loadEn := FALSE;
  loadAddr := 0;
  storeEn := inner_arbiter.write_enable;
  storeAddr := inner_arbiter.write_address;
  storeData := inner_arbiter.data_to_memory;

  
MODULE test_module__mc_loadless__write_memory_arbiter(pValid_0, pValid_1, pValid_2, pValid_3, pValid_4, address_in_0, address_in_1, address_in_2, address_in_3, address_in_4,
  data_in_0, data_in_1, data_in_2, data_in_3, data_in_4, nReady_0, nReady_1, nReady_2, nReady_3, nReady_4)

  VAR
  priority_gen : test_module__mc_loadless__write_memory_arbiter__priority(pValid_0, nReady_0, pValid_1, nReady_1, pValid_2, nReady_2, pValid_3, nReady_3, pValid_4, nReady_4);
  valid_0_in : boolean;
  valid_1_in : boolean;
  valid_2_in : boolean;
  valid_3_in : boolean;
  valid_4_in : boolean;

  ASSIGN
  init(valid_0_in) := FALSE;
  init(valid_1_in) := FALSE;
  init(valid_2_in) := FALSE;
  init(valid_3_in) := FALSE;
  init(valid_4_in) := FALSE;
  next(valid_0_in) :=  priority_gen.priority_0;
  next(valid_1_in) :=  priority_gen.priority_1;
  next(valid_2_in) :=  priority_gen.priority_2;
  next(valid_3_in) :=  priority_gen.priority_3;
  next(valid_4_in) :=  priority_gen.priority_4;


  DEFINE
  write_addr_in := case
    priority_gen.priority_0 = TRUE : address_in_0;
    priority_gen.priority_1 = TRUE : address_in_1;
    priority_gen.priority_2 = TRUE : address_in_2;
    priority_gen.priority_3 = TRUE : address_in_3;
    priority_gen.priority_4 = TRUE : address_in_4;
    TRUE: 0;
  esac;
  write_data_in := case
    priority_gen.priority_0 = TRUE : data_in_0;
    priority_gen.priority_1 = TRUE : data_in_1;
    priority_gen.priority_2 = TRUE : data_in_2;
    priority_gen.priority_3 = TRUE : data_in_3;
    priority_gen.priority_4 = TRUE : data_in_4;
    TRUE: 0;
  esac;

  // output
  DEFINE
  ready_0 := priority_gen.priority_0 & nReady_0;
  ready_1 := priority_gen.priority_1 & nReady_1;
  ready_2 := priority_gen.priority_2 & nReady_2;
  ready_3 := priority_gen.priority_3 & nReady_3;
  ready_4 := priority_gen.priority_4 & nReady_4;
  valid_0 := valid_0_in;
  valid_1 := valid_1_in;
  valid_2 := valid_2_in;
  valid_3 := valid_3_in;
  valid_4 := valid_4_in;
  write_address := write_addr_in;
  data_to_memory := write_data_in;
  write_enable := priority_gen.priority_0 | priority_gen.priority_1 | priority_gen.priority_2 | priority_gen.priority_3 | priority_gen.priority_4;
  enable := write_enable;


MODULE test_module__mc_loadless__write_memory_arbiter__priority(req_0, data_ready_0, req_1, data_ready_1, req_2, data_ready_2, req_3, data_ready_3, req_4, data_ready_4)
  DEFINE
  que_el_0 := req_0 & data_ready_0;
  prior_0 := que_el_0;
  prior_1 := que_el_0 | prior_0;
  que_el_1 := req_1 & data_ready_1 & !prior_1;
  prior_2 := que_el_1 | prior_1;
  que_el_2 := req_2 & data_ready_2 & !prior_2;
  prior_3 := que_el_2 | prior_2;
  que_el_3 := req_3 & data_ready_3 & !prior_3;
  prior_4 := que_el_3 | prior_3;
  que_el_4 := req_4 & data_ready_4 & !prior_4;

  // output
  DEFINE
  priority_0 := que_el_0;
  priority_1 := que_el_1;
  priority_2 := que_el_2;
  priority_3 := que_el_3;
  priority_4 := que_el_4;



  
MODULE test_module__mc_loadless__mc_control(memStart_valid, memEnd_ready, ctrlEnd_valid, all_requests_done)

  VAR
  memStart_ready_in : boolean;
  memEnd_valid_in : boolean;
  ctrlEnd_ready_in : boolean;

  ASSIGN
  init(memStart_ready_in) := TRUE;
  next(memStart_ready_in) := case
    memEnd_valid_in & memEnd_ready : TRUE;
    memStart_valid & memStart_ready_in : FALSE;
    TRUE : memStart_ready_in;
  esac;
  init(memEnd_valid_in) := FALSE;
  next(memEnd_valid_in) := case
    memEnd_valid_in & memEnd_ready : FALSE;
    ctrlEnd_valid & all_requests_done : TRUE;
    TRUE : memEnd_valid_in;
  esac;
  init(ctrlEnd_ready_in) := FALSE;
  next(ctrlEnd_ready_in) := case
    ctrlEnd_valid & ctrlEnd_ready_in : FALSE;
    ctrlEnd_valid & all_requests_done : TRUE;
    TRUE : ctrlEnd_ready_in;
  esac;

  // outputs
  DEFINE
  memStart_ready := memStart_ready_in;
  memEnd_valid := memEnd_valid_in;
  ctrlEnd_ready := ctrlEnd_ready_in;


  
MODULE test_module__read_memory_arbiter(pValid_0, pValid_1, pValid_2, pValid_3, pValid_4, address_in_0, address_in_1, address_in_2, address_in_3, address_in_4, nReady_0, nReady_1, nReady_2, nReady_3, nReady_4, data_from_memory)

  VAR
  priority_gen : test_module__read_memory_arbiter__priority(pValid_0, nReady_0, pValid_1, nReady_1, pValid_2, nReady_2, pValid_3, nReady_3, pValid_4, nReady_4);
  valid_0_in : boolean;
  valid_1_in : boolean;
  valid_2_in : boolean;
  valid_3_in : boolean;
  valid_4_in : boolean;
  sel_prev0 : boolean;
  sel_prev1 : boolean;
  sel_prev2 : boolean;
  sel_prev3 : boolean;
  sel_prev4 : boolean;
  out_reg_0 : signed word [16];
  out_reg_1 : signed word [16];
  out_reg_2 : signed word [16];
  out_reg_3 : signed word [16];
  out_reg_4 : signed word [16];

  ASSIGN
  init(valid_0_in) := FALSE;
  init(valid_1_in) := FALSE;
  init(valid_2_in) := FALSE;
  init(valid_3_in) := FALSE;
  init(valid_4_in) := FALSE;
  next(valid_0_in) :=  case
    priority_gen.priority_0 : TRUE;
    nReady_0 : FALSE;
    TRUE : valid_0_in;
  esac;
  next(valid_1_in) :=  case
    priority_gen.priority_1 : TRUE;
    nReady_1 : FALSE;
    TRUE : valid_1_in;
  esac;
  next(valid_2_in) :=  case
    priority_gen.priority_2 : TRUE;
    nReady_2 : FALSE;
    TRUE : valid_2_in;
  esac;
  next(valid_3_in) :=  case
    priority_gen.priority_3 : TRUE;
    nReady_3 : FALSE;
    TRUE : valid_3_in;
  esac;
  next(valid_4_in) :=  case
    priority_gen.priority_4 : TRUE;
    nReady_4 : FALSE;
    TRUE : valid_4_in;
  esac;

  init(sel_prev0) := FALSE;
  init(sel_prev1) := FALSE;
  init(sel_prev2) := FALSE;
  init(sel_prev3) := FALSE;
  init(sel_prev4) := FALSE;
  next(sel_prev0) := priority_gen.priority_0;
  next(sel_prev1) := priority_gen.priority_1;
  next(sel_prev2) := priority_gen.priority_2;
  next(sel_prev3) := priority_gen.priority_3;
  next(sel_prev4) := priority_gen.priority_4;

  init(out_reg_0) := 0;
  init(out_reg_1) := 0;
  init(out_reg_2) := 0;
  init(out_reg_3) := 0;
  init(out_reg_4) := 0;
  next(out_reg_0) := sel_prev0 ? data_from_memory : out_reg_0;
  next(out_reg_1) := sel_prev1 ? data_from_memory : out_reg_1;
  next(out_reg_2) := sel_prev2 ? data_from_memory : out_reg_2;
  next(out_reg_3) := sel_prev3 ? data_from_memory : out_reg_3;
  next(out_reg_4) := sel_prev4 ? data_from_memory : out_reg_4;

  // output
  DEFINE
  ready_0 := priority_gen.priority_0 & nReady_0;
  ready_1 := priority_gen.priority_1 & nReady_1;
  ready_2 := priority_gen.priority_2 & nReady_2;
  ready_3 := priority_gen.priority_3 & nReady_3;
  ready_4 := priority_gen.priority_4 & nReady_4;
  valid_0 := valid_0_in;
  valid_1 := valid_1_in;
  valid_2 := valid_2_in;
  valid_3 := valid_3_in;
  valid_4 := valid_4_in;
  data_out_0 := sel_prev0 ? data_from_memory : out_reg_0;
  data_out_1 := sel_prev1 ? data_from_memory : out_reg_1;
  data_out_2 := sel_prev2 ? data_from_memory : out_reg_2;
  data_out_3 := sel_prev3 ? data_from_memory : out_reg_3;
  data_out_4 := sel_prev4 ? data_from_memory : out_reg_4;
  
  read_enable := priority_gen.priority_0 | priority_gen.priority_1 | priority_gen.priority_2 | priority_gen.priority_3 | priority_gen.priority_4;
  read_address := case
    priority_gen.priority_0 = TRUE : address_in_0;
    priority_gen.priority_1 = TRUE : address_in_1;
    priority_gen.priority_2 = TRUE : address_in_2;
    priority_gen.priority_3 = TRUE : address_in_3;
    priority_gen.priority_4 = TRUE : address_in_4;
    TRUE: 0;
  esac;


MODULE test_module__read_memory_arbiter__priority(req_0, data_ready_0, req_1, data_ready_1, req_2, data_ready_2, req_3, data_ready_3, req_4, data_ready_4)
  DEFINE
  que_el_0 := req_0 & data_ready_0;
  prior_0 := que_el_0;
  prior_1 := que_el_0 | prior_0;
  que_el_1 := req_1 & data_ready_1 & !prior_1;
  prior_2 := que_el_1 | prior_1;
  que_el_2 := req_2 & data_ready_2 & !prior_2;
  prior_3 := que_el_2 | prior_2;
  que_el_3 := req_3 & data_ready_3 & !prior_3;
  prior_4 := que_el_3 | prior_3;
  que_el_4 := req_4 & data_ready_4 & !prior_4;

  // output
  DEFINE
  priority_0 := que_el_0;
  priority_1 := que_el_1;
  priority_2 := que_el_2;
  priority_3 := que_el_3;
  priority_4 := que_el_4;




