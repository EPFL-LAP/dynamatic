[Home](../../README.md) <span>&ensp;</span> [Usage](Usage.md)<span>&ensp;</span> [Modification](AdvancedUsage.md)<span>&ensp;</span> [Advanced-Build](AdvancedBuild.md) <span>&ensp;</span>[Examples](Examples.md) <span>&ensp;</span>[Dependencies](Dependencies.md) <span>&ensp;</span>[Development](WorkInProgress.md)
# Modifying Dynamatic
>This is a sequel to the [Using Dynamatic](Usage.md) tutorial, and as such requires that you are already familiar with the concepts discussed there.  

In this tutorial, we will write a small compiler optimization pass in C++ that will transform dataflow muxes into merges in an attempt to optimize our circuits' area and throughput. While we will write a bit of C++ in this tutorial, it does not require much knowledge in the language.

Below are some technical details about this tutorial.

- All resources are located in the repository's [tutorials/Introduction/](../../tutorials/Introduction) folder. Data exclusive to this chapter is located in the Ch2 subfolder, but we will also reuse data from the [using dynamatic](Usage.md) section.
- All relative paths mentionned throughout the tutorial are assumed to start at Dynamatic's top-level folder.
- We assume that you have already built Dynamatic from source using the instructions in the [simple build instructions](../../README.md) or that you have access to a Docker container that has a pre-built version of Dynamatic .

This tutorial is divided into the following sections.

1. [Spotting an optimization opportunity](#spotting-an-optimization-opportunity) | We take another look at the circuit from the previous tutorial and spot something that looks optimizable.
2. [Writing a small compiler pass](#writing-a-small-compiler-pass) | We implement the optimization as a compiler pass, and add it the compilation script to use it.
3. [Testing our pass](#testing-our-pass) | We test our pass to make sure it works as intended, and find out that it may not.
4. [A problem, and a solution!](#a-problem-and-a-solution) | After identifying a problem in one of our circuits, we implement a quick-and-dirty fix to make the circuit correct again.
5. [Conclusion](#conclusion) | We reflect on everything we just accomplished.

## Spotting an optimization opportunity
Let's start by re-considering the [same `loop_multiply` kernel](../../tutorials/Introduction/Ch1/loop_multiply.c) from the using Dynamatic tutorial. See its definition below.
```
// The kernel under consideration
unsigned loop_multiply(in_int_t a[N]) {
  unsigned x = 2;
  for (unsigned i = 0; i < N; ++i) {
    if (a[i] == 0)
      x = x * x;
  }
  return x;
}
```
This simple kernel: 
- multiplies a number by itself at each iteration of a simple loop from 0 to a number, `N`, where the corresponding element of an array equals 0. 
- returns the calculated value after the loop exits.

>If you have deleted the data generated by the synthesis flow on this kernel, you can regenerate it fully using the [loop-multiply.dyn](../../tutorials/Introduction/Ch2/loop-multiply.dyn) frontend script that has already been written for you. Just run the following command from Dynamatic's top-level folder.
```
./bin/dynamatic --run tutorials/Introduction/Ch2/loop-multiply.dyn
```
This will compile the C kernel, functionally verify the generated VHDL, and re-open the dataflow visualizer. The `[INFO] Simulation succeeded` message in the output (after the `simulate` command) indicates that outputs of the VHDL design matched those of the original C kernel. All output files are generated in [tutorials/Introduction/usingDynamatic/out](../Tutorials/tutorials/Introduction/usingDynamatic/out%60).

> Tip:  
> Identify all muxes in the circuit and derive their purpose in this circuit. Remember that muxes have an arbitrary number of ```data``` inputs (here it is always 2) and one `select` input, which selects which valid data input gets forwarded to the output. Note that, in general, the `select` input of muxes is generated by the `index` output of the same block's control merge.
>
Another dataflow component that is similar to the mux in purpose is the merge. Identically to the mux, the merge has an arbitrary number of `data` inputs, one of which gets forwarded to the output when it is valid. However, the two dataflow components have two key differences:
- The merge does not have a `select` input. Instead, at any given cycle, if any of its data inputs is valid and if its data output is ready, it will transfer a token to the output.
- The merge does not provide any guarantee on input consumption order if at any given cycle multiple of its inputs are valid and its data output is ready. In those situations, it will simply transfer one of its input tokens to its output.

Due to this "simpler" interface, a merge is generally smaller in area than a corresponding mux with the same number of `data` inputs. Replacing a mux with a merge may also speed up circuit execution since the merge does not have to wait for the arrival of a valid `select` token to transfer one of its `data` inputs to its output.

Let's try to make this circuit smaller by writing a compiler pass that will automatically replace all muxes with equivalent merges then!

## Writing a small compiler pass
In this section, we will add a small transformation pass that achieves the optimization opportunity we identified in the previous section. We will not go into much details into how C++ or MLIR works, our focus will be instead in writing something minimal that accomplishes the job cleanly. For a more complete tutorial on pass-writing, feel free to go through the [Creating Passes](CreatingPasses.md) tutorial after completing this one.

Creating this pass will involve creating 2 new source files and making minor editions to 3 existing source files. In order, we will

1. [Declare the pass in TableGen](#declaring-the-pass-in-tablegen) (a LLVM?MLIR language that eventually transpiles to C++)
2. [Write a minimal C++ header for the pass](#a-minimal-c-header-for-the-pass)
3. [Implement the pass in C++](#implementing-the-pass)
4. [Make the new source file we created part of Dynamatic's build process](#making-our-pass-visible)
5. [Edit a generic header to make our pass visible to Dynamatic's optimizer](#testing-our-pass)

### Declaring the pass in TableGen
The first thing we need to do is declare our pass somewhere. In LLVM/IR. this happens in the TableGen language, a declarative format that ultimately transpiles to C++ during the build process to automatically generate a lot of boilerplate C++ code.

Open the `include/dynamatic/Transforms/Passes.td` file and copy-and-paste the following snippet anywhere below the include lines at the top of the file.

```
def HandshakeMuxToMerge : DynamaticPass<"handshake-mux-to-merge"> {
  let summary = "Transform all muxes into merges.";
  let description = [{
    Transform all muxes within the IR into merges with identical data operands. 
  }];
  let constructor = "dynamatic::createHandshakeMuxToMerge()";
}
```
This code
- declares a compiler pass whose C++ class name will be based on `HandshakeMuxToMerge` 
- the pass can be called using the `--handshake-mux-to-merge` flag from Dynamatic's optimizer (we will go into more details into using Dynamatic's optimizer in the ["Testing our pass" section](#testing-our-pass)).

 The `summary` and `description` fields are optional but useful to describe the pass's purpose. Finally, the `constructor` field indicates the name of a C++ function that should return an instance of our pass. We will declare and then define this method in teh next two sections.

### A minimal C++ header for the pass
We now need to write a small C++ header for our new pass. Each pass has one, and they are for the large part always structured in the same way. 
- Create a file in `include/dynamatic/Transforms` called `HandshakeMuxToMerge.h` and paste the following chunk of code into it.
```
/// Classical C-style header guard
#ifndef DYNAMATIC_TRANSFORMS_HANDSHAKEMUXTOMERGE_H
#define DYNAMATIC_TRANSFORMS_HANDSHAKEMUXTOMERGE_H

/// Include some basic headers
#include "dynamatic/Support/DynamaticPass.h"
#include "dynamatic/Support/LLVM.h"
#include "mlir/Pass/Pass.h"

namespace dynamatic {

/// The following include file is autogenerated by LLVM/MLIR during the build
/// process from the Passes.td file we just edited. We only want to include the
/// part of the file that refers to our pass (it contains delcaration code for
/// all transformation passes), which we select using the two macros below. 
#define GEN_PASS_DECL_HANDSHAKEMUXTOMERGE
#define GEN_PASS_DEF_HANDSHAKEMUXTOMERGE
#include "dynamatic/Transforms/Passes.h.inc"

/// The pass constructor, with the same name we specified in TableGen in the
/// previous subsection.
std::unique_ptr<dynamatic::DynamaticPass> createHandshakeMuxToMerge();

} // namespace dynamatic

#endif // DYNAMATIC_TRANSFORMS_HANDSHAKEMUXTOMERGE_H
```
The file does two important things:
- It includes C++ code auto-generated from the `Passes.td` file we just edited.
- It declares the pass header that we announced in the pass's TableGen declaration

Now that all declarations are made, it is time to actually implement our IR transformation!

### Implementing the pass
Create a file in `lib/Transforms` called `HandShakeMuxToMerge.cpp` in which we will implement ourpass.
Paste the following code into it:
```
/// Include the header we just created.
#include "dynamatic/Transforms/HandshakeMuxToMerge.h"

/// Include some other useful headers.
#include "dynamatic/Dialect/Handshake/HandshakeOps.h"
#include "dynamatic/Support/CFG.h"
#include "mlir/Transforms/GreedyPatternRewriteDriver.h"

using namespace dynamatic;

namespace {

/// Simple driver for the pass that replaces all muxes with merges.
struct HandshakeMuxToMergePass
    : public dynamatic::impl::HandshakeMuxToMergeBase<HandshakeMuxToMergePass> {

  void runDynamaticPass() override {
    // This is the top-level operation in all MLIR files. All the IR is nested
    // within it
    mlir::ModuleOp mod = getOperation();
    MLIRContext *ctx = &getContext();

    // Define the set of rewrite patterns we want to apply to the IR
    RewritePatternSet patterns(ctx);

    // Run a greedy pattern rewriter on the entire IR under the top-level module
    // operation
    mlir::GreedyRewriteConfig config;
    if (failed(applyPatternsAndFoldGreedily(mod, std::move(patterns), config))) {
      // If the greedy pattern rewriter fails, the pass must also fail
      return signalPassFailure();
    }
  };
};
}; // namespace

/// Implementation of our pass constructor, which just returns an instance of
/// the `HandshakeMuxToMergePass` struct. 
std::unique_ptr<dynamatic::DynamaticPass>
dynamatic::createHandshakeMuxToMerge() {
  return std::make_unique<HandshakeMuxToMergePass>();
}
```
This file, at the bottom, 
- implements the pass constructor we declared in the header. 
- This constructor returns an instance of a struct defined just above (do not mind the slightly convoluted struct declaration, which showcases the [curiously recurring template pattern](https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern) C++ idiom that is used extensively throughout MLIR/Dynamatic) whose single method `runDynamaticPass` defines what happens when the pass is called. 

In our case, we want to leverage MLIR's greedy pattern rewriter infrastructure to match  on all muxes in the IR and replace them with merges with identical data inputs. 
>If you would like to know more about how greedy pattern rewriting works, feel free to check out MLIR's [official documentation](../Tutorials/Introduction/link) on the subject.  


For this simple pass, you do not need to understand exactly how it works except that it can match and try to rewrite certain operations inside the IR based on a set of user-provided rewrite patterns. Speaking of rewrite patterns, let's add our own to the file just above the `HandshakeMuxToMergePass` struct definition. Paste the following into the file:
```
/// Rewrite pattern that will match on all muxes in the IR and replace each of
/// them with a merge taking the same inputs (except the `select` input which
/// merges do not have due to their undeterministic nature).
struct ReplaceMuxWithMerge : public OpRewritePattern<handshake::MuxOp> {
  using OpRewritePattern<handshake::MuxOp>::OpRewritePattern;

  LogicalResult matchAndRewrite(handshake::MuxOp muxOp,
                                PatternRewriter &rewriter) const override {
    // Retrieve all mux inputs except the `select`
    ValueRange dataOperands = muxOp.getDataOperands();
    // Create a merge in the IR at the mux's position and with the same data
    // inputs (or operands, in MLIR jargon)
    handshake::MergeOp mergeOp =
        rewriter.create<handshake::MergeOp>(muxOp.getLoc(), dataOperands);
    // Make the merge part of the same basic block (BB) as the mux
    inheritBB(muxOp, mergeOp);
    // Retrieve the merge's output (or result, in MLIR jargon)
    Value mergeResult = mergeOp.getResult();
    // Replace usages of the mux's output with the new merge's output
    rewriter.replaceOp(muxOp, mergeResult);
    // Signal that the pattern succeeded in rewriting the mux
    return success();
  }
};
```
The rewrite pattern, called `ReplaceMuxWithMerge`, matches on operations of type `handshake::MuxOp` (the mux operation is apart of the Handshake dialect) as indicated by its declaration. Each time the greedy pattern rewriter finds a mux in the IR, it will call the pattern's `matchAndRewrite` method, providing it with the particular operation it matched on as well as with a `PatternRewrite` object to allow us to modify the IR. For this simple pass, we want to transform all muxes into merges so the rewrite pattern is very short:
- First, we extract the mux's data inputs
- Then we create a merge operation at the same location in the IR and with the same data inputs
- Finally, we tell the rewriter to replace the mux with the merge. This "rewires" the IR by making users of the mux's output channel use the merge's output channel instead, and deletes the original mux.

To complete the pass implementation, we simply have to provide the rewrite pattern to the greedy pattern rewriter. Just add the following call to `patterns.add` inside `runDynamaticPass` after declaring the pattern set in your `HandshakeMuxToMerge.cpp` file.
```
RewritePatternSet patterns(ctx);
patterns.add<ReplaceMuxWithMerge>(ctx);
```

Congratulations! You have now implemented your first Dynamatic pass. We just have two simple edit to make before we can start using it.

### Adding our pass to the build process
We need to make the build process aware of the new source file we just wrote. Navigate to `lib/Transforms/CMakeLists.txt` and add the name of the file you created in the previous section next to the other `.cpp` files in the `add_dynamatic_library` statement.
```
add_dynamatic_library(DynamaticTransforms
  HandshakeMuxToMerge.cpp # Add this line
  ArithReduceStrength.cpp
  ... # other .cpp files

  DEPENDS
  ...
)
```
### Making our pass visible
Finally, we need to make Dynamatic's optimizer aware of our new pass. Navigate to `include/dynamatic/Transforms/Passes.h` and add the header you wrote a couple of subsections ago to the list of include files
```
#ifndef DYNAMATIC_TRANSFORMS_PASSES_H
#define DYNAMATIC_TRANSFORMS_PASSES_H

#include "dynamatic/Transforms/HandshakeMuxToMerge.h" // Add this line
... // other include files
```
### Testing our pass
Now that the pass is part of the project's source code, we just have to partially re-build Dynamatic to use it.
Simply navigate to the top-level `build` directory from the terminal and run `ninja`
```
cd build && ninja && cd ..
```
If you see `Build Successful` (<span style="color:red;">I actually don't see success. It just yields no error</span>) printed on the terminal, then everythin worked and the pass is now part of Dynamatic. Let's go modify our compilation script (which is called by the frontend's `compile` command) to run it as part of the normal synthesis flow.

Open `tools/dynamatic/scripts/compile.sh` and locate the following call to Dynamatic's optimizer
```
# handshake transformations
"$DYNAMATIC_OPT_BIN" "$F_HANDSHAKE" \
  --handshake-minimize-lsq-usage \
  --handshake-concretize-index-type="width=32" \
  --handshake-minimize-cst-width --handshake-optimize-bitwidths="legacy" \
  --handshake-materialize --handshake-infer-basic-blocks \
  > "$F_HANDSHAKE_TRANSFORMED"    
exit_on_fail "Failed to apply transformations to handshake" \
  "Applied transformations to handshake"
```
This a compilation step where we apply a number of optimizations/transformatios to our Handshake-level IR for performance and correctness, and is thus a perfect place to insert our new pass. Remember that we declared our pass in TableGen to be associated with the `--handshake-mux-to-merge` optimizer flag. We just have to add the flag to the optimizer call to run our new pass.
```
# handshake transformations
"$DYNAMATIC_OPT_BIN" "$F_HANDSHAKE" \
  --handshake-mux-to-merge \
  --handshake-minimize-lsq-usage \
  --handshake-concretize-index-type="width=32" \
  --handshake-minimize-cst-width --handshake-optimize-bitwidths="legacy" \
  --handshake-materialize --handshake-infer-basic-blocks \
  > "$F_HANDSHAKE_TRANSFORMED"    
exit_on_fail "Failed to apply transformations to handshake" \
  "Applied transformations to handshake"
```
Done! Now you can re-run the same frontend script as earlier(`.bin/dynamatic --run tutorials/Introduction/Ch2/loop-multiply.dyn`) to see the results of your work! Note that the circuit still functionally verifies during the `simulate` step as the frontend prints `[INFO] Simulation succeeded`

>Tip  
Notice that all muxes have been turned into merges. Also observe that there are no control merges left in the circuit. Indeed, a control merge is just a merge with an additional `index` output indicating which valid `data` input was selected. The IR no longer uses any of these `index` outputs since muxes have been deleted. So, Dynamatic automatically downgraded all control merges to simpler and cheaper merges to save on circuit area.
>

Surely this will work on all circuits, which will from now on all be smaller than before, right?

### A problem, and a solution
Just to be sure, let's try our optimization on a dofferent yet similar C kernel called `loop_store`.
```
// The number of loop iterations
#define N 8

// The kernel under consideration
void loop_store(inout_int_t a[N]) {
  for (unsigned i = 0; i < N; ++i) {
    unsigned x = i;
    if (a[i] == 0)
      x = x * x;
    a[i] = x;
  }
}
```

You can find the source code for this function in [tutorials/Introduction/ch2/loop_store.c](../../tutorials/Introduction/Ch2/loop_store.c)

This has the same rough structure as our previous example, except that now the kernel stores the squared iteration index in the array at each iteration where the corresponding array element is 0; otherwise, it stores the index itself.

Now run the [tutorials/Introduction/Ch2/loop-store.dyn](../../tutorials/Introduction/Ch2/loop-store.dyn) frontend script. It is almost indentifcal to the previous frontend script we used; its only difference is that it synthesizes `loop_store.c` instead of `loop_multiply.c`
```
./bin/dynamatic --run tutorials/Introduction/Ch2/loop-store.dyn
```
Observe the frontend's output when running `simulate`. You should see the following.
