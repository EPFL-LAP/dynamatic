# Signal Manager Examples

The signal manager wraps each unit (e.g., `addi`, `buffer`, etc.) and forwards extra signals.

The generator code may seem abstract without concrete examples, so here are some generated signal managers.

Comments starting with `Note:` are for clarity and are not part of the generated output.

## `cond_br` (normal signal manager)

```vhdl
-- Note: Headers and entity are generated by `generate_entity`.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.types.all;

-- Entity of signal manager
entity handshake_cond_br_2 is
  port(
    clk : in std_logic;
    rst : in std_logic;
    data : in std_logic_vector(32 - 1 downto 0);
    data_valid : in std_logic;
    data_ready : out std_logic;
    data_spec : in std_logic_vector(1 - 1 downto 0);
    condition : in std_logic_vector(1 - 1 downto 0);
    condition_valid : in std_logic;
    condition_ready : out std_logic;
    condition_spec : in std_logic_vector(1 - 1 downto 0);
    trueOut : out std_logic_vector(32 - 1 downto 0);
    trueOut_valid : out std_logic;
    trueOut_ready : in std_logic;
    trueOut_spec : out std_logic_vector(1 - 1 downto 0);
    falseOut : out std_logic_vector(32 - 1 downto 0);
    falseOut_valid : out std_logic;
    falseOut_ready : in std_logic;
    falseOut_spec : out std_logic_vector(1 - 1 downto 0)
  );
end entity;

-- Architecture of signal manager (normal)
architecture arch of handshake_cond_br_2 is
begin

  -- Note: forwarded_extra_signals is {"spec": "data_spec or condition_spec"}.
  -- Note: these assignments are generated by `_forward_extra_signals`.
  trueOut_spec <= data_spec or condition_spec;
  falseOut_spec <= data_spec or condition_spec;

  inner : entity work.handshake_cond_br_2_inner(arch)
    port map(
      clk => clk,
      rst => rst,
      -- Note: these port forwardings are generated by `generate_inner_port_forwarding`.
      data => data,
      data_valid => data_valid,
      data_ready => data_ready,
      condition => condition,
      condition_valid => condition_valid,
      condition_ready => condition_ready,
      trueOut => trueOut,
      trueOut_valid => trueOut_valid,
      trueOut_ready => trueOut_ready,
      falseOut => falseOut,
      falseOut_valid => falseOut_valid,
      falseOut_ready => falseOut_ready
    );
end architecture;
```

## `muli` (buffered signal manager)

```vhdl
-- Note: Headers and entity are generated by `generate_entity`.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.types.all;

-- Entity of signal manager
entity handshake_muli_0 is
  port(
    clk : in std_logic;
    rst : in std_logic;
    lhs : in std_logic_vector(32 - 1 downto 0);
    lhs_valid : in std_logic;
    lhs_ready : out std_logic;
    lhs_spec : in std_logic_vector(1 - 1 downto 0);
    rhs : in std_logic_vector(32 - 1 downto 0);
    rhs_valid : in std_logic;
    rhs_ready : out std_logic;
    rhs_spec : in std_logic_vector(1 - 1 downto 0);
    result : out std_logic_vector(32 - 1 downto 0);
    result_valid : out std_logic;
    result_ready : in std_logic;
    result_spec : out std_logic_vector(1 - 1 downto 0)
  );
end entity;

-- Architecture of signal manager (buffered)
architecture arch of handshake_muli_0 is
  signal buff_in, buff_out : std_logic_vector(1 - 1 downto 0);
  signal transfer_in, transfer_out : std_logic;
begin

  -- Note: these are `transfer_logic`.
  transfer_in <= lhs_valid and lhs_ready;
  transfer_out <= result_valid and result_ready;

  -- Note: forwarded_extra_signals is {"spec": "lhs_spec or rhs_spec"}.
  -- Note: these are `signal_assignments`.
  buff_in(0 downto 0) <= lhs_spec or rhs_spec;
  result_spec <= buff_out(0 downto 0);

  inner : entity work.handshake_muli_0_inner(arch)
    port map(
      clk => clk,
      rst => rst,
      -- Note: these port forwardings are generated by `generate_inner_port_forwarding`.
      lhs => lhs,
      lhs_valid => lhs_valid,
      lhs_ready => lhs_ready,
      rhs => rhs,
      rhs_valid => rhs_valid,
      rhs_ready => rhs_ready,
      result => result,
      result_valid => result_valid,
      result_ready => result_ready
    );

  -- Note: ofifo is generated as a dependency to store extra signals
  buff : entity work.handshake_muli_0_buff(arch)
    port map(
      clk => clk,
      rst => rst,
      ins => buff_in,
      ins_valid => transfer_in,
      ins_ready => open,
      outs => buff_out,
      outs_valid => open,
      outs_ready => transfer_out
    );
end architecture;
```

## `fork` (concat signal manager)

```vhdl
-- Note: Headers and entity are generated by `generate_entity`.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.types.all;

-- Entity of signal manager
entity handshake_fork_1 is
  port(
    clk : in std_logic;
    rst : in std_logic;
    ins : in std_logic_vector(32 - 1 downto 0);
    ins_valid : in std_logic;
    ins_ready : out std_logic;
    ins_spec : in std_logic_vector(1 - 1 downto 0);
    outs : out data_array(4 - 1 downto 0)(32 - 1 downto 0);
    outs_valid : out std_logic_vector(4 - 1 downto 0);
    outs_ready : in std_logic_vector(4 - 1 downto 0);
    outs_0_spec : out std_logic_vector(1 - 1 downto 0);
    outs_1_spec : out std_logic_vector(1 - 1 downto 0);
    outs_2_spec : out std_logic_vector(1 - 1 downto 0);
    outs_3_spec : out std_logic_vector(1 - 1 downto 0)
  );
end entity;

-- Architecture of signal manager (concat)
architecture arch of handshake_fork_1 is
  -- Concatenated data and extra signals
  signal ins_inner : std_logic_vector(33 - 1 downto 0);
  signal outs_inner : data_array(4 - 1 downto 0)(33 - 1 downto 0);
begin
  -- Note: these are `concat_logic`.
  ins_inner(32 - 1 downto 0) <= ins;
  ins_inner(32 downto 32) <= ins_spec;
  outs(0) <= outs_inner(0)(32 - 1 downto 0);
  outs_0_spec <= outs_inner(0)(32 downto 32);
  outs(1) <= outs_inner(1)(32 - 1 downto 0);
  outs_1_spec <= outs_inner(1)(32 downto 32);
  outs(2) <= outs_inner(2)(32 - 1 downto 0);
  outs_2_spec <= outs_inner(2)(32 downto 32);
  outs(3) <= outs_inner(3)(32 - 1 downto 0);
  outs_3_spec <= outs_inner(3)(32 downto 32);

  -- Note: Inner fork is generated with concatenated bitwidth
  inner : entity work.handshake_fork_1_inner(arch)
    port map(
      clk => clk,
      rst => rst,
      -- Note: `ins` is forwarded to concatenated `ins_inner`.
      ins => ins_inner,
      ins_valid => ins_valid,
      ins_ready => ins_ready,
      -- Note: `outs` is forwarded to concatenated `outs_inner`.
      outs => outs_inner,
      outs_valid => outs_valid,
      outs_ready => outs_ready
    );
end architecture;
```

## `mux` (mergebb signal manager)

```vhdl
-- Note: Headers and entity are generated by `generate_entity`.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.types.all;

-- Entity of signal manager
entity handshake_mux_0 is
  port(
    clk : in std_logic;
    rst : in std_logic;
    ins : in data_array(2 - 1 downto 0)(32 - 1 downto 0);
    ins_valid : in std_logic_vector(2 - 1 downto 0);
    ins_ready : out std_logic_vector(2 - 1 downto 0);
    -- Note: spec is only present at index 1 (not 0).
    ins_1_spec : in std_logic_vector(1 - 1 downto 0);
    index : in std_logic_vector(1 - 1 downto 0);
    index_valid : in std_logic;
    index_ready : out std_logic;
    outs : out std_logic_vector(32 - 1 downto 0);
    outs_valid : out std_logic;
    outs_ready : in std_logic;
    outs_spec : out std_logic_vector(1 - 1 downto 0)
  );
end entity;

-- Architecture of signal manager (mergebb)
architecture arch of handshake_mux_0 is
  -- Lacking spec inputs
  signal ins_0_spec : std_logic_vector(0 downto 0);
  -- Concatenated data and extra signals
  signal ins_inner : data_array(2 - 1 downto 0)(33 - 1 downto 0);
  signal outs_inner : std_logic_vector(33 - 1 downto 0);
begin
  -- Note: This is `lacking_spec_port_assignments`.
  ins_0_spec <= "0";
  -- Note: These are `concat_logic`.
  ins_inner(0)(32 - 1 downto 0) <= ins(0);
  ins_inner(0)(32 downto 32) <= ins_0_spec;
  ins_inner(1)(32 - 1 downto 0) <= ins(1);
  ins_inner(1)(32 downto 32) <= ins_1_spec;
  outs <= outs_inner(32 - 1 downto 0);
  outs_spec <= outs_inner(32 downto 32);

  -- Note: Inner mux is generated with concatenated bitwidth
  inner : entity work.handshake_mux_0_inner(arch)
    port map(
      clk => clk,
      rst => rst,
      -- Note: `ins` is forwarded to concatenated `ins_inner`.
      ins => ins_inner,
      ins_valid => ins_valid,
      ins_ready => ins_ready,
      -- Note: `index` is not concatenated and directly forwarded to external signal.
      index => index,
      index_valid => index_valid,
      index_ready => index_ready,
      -- Note: `outs` is forwarded to concatenated `outs_inner`.
      outs => outs_inner,
      outs_valid => outs_valid,
      outs_ready => outs_ready
    );
end architecture;
```
