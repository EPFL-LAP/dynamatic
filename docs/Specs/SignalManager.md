# Signal Manager Examples

The signal manager wraps each unit (e.g., `addi`, `buffer`, etc.) and forwards extra signals.

The generator code may seem abstract without concrete examples, so here are some generated signal managers.

Comments starting with `Note:` are for clarity and are not part of the generated output.

## `cond_br` (normal signal manager)

```vhdl
-- Note: Headers and entity are generated by `generate_entity`.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.types.all;

-- Entity of signal manager
entity handshake_cond_br_2 is
  port(
    clk : in std_logic;
    rst : in std_logic;
    data : in std_logic_vector(32 - 1 downto 0);
    data_valid : in std_logic;
    data_ready : out std_logic;
    data_spec : in std_logic_vector(1 - 1 downto 0);
    condition : in std_logic_vector(1 - 1 downto 0);
    condition_valid : in std_logic;
    condition_ready : out std_logic;
    condition_spec : in std_logic_vector(1 - 1 downto 0);
    trueOut : out std_logic_vector(32 - 1 downto 0);
    trueOut_valid : out std_logic;
    trueOut_ready : in std_logic;
    trueOut_spec : out std_logic_vector(1 - 1 downto 0);
    falseOut : out std_logic_vector(32 - 1 downto 0);
    falseOut_valid : out std_logic;
    falseOut_ready : in std_logic;
    falseOut_spec : out std_logic_vector(1 - 1 downto 0)
  );
end entity;

-- Architecture of signal manager (normal)
architecture arch of handshake_cond_br_2 is
begin
  -- Note: `forwarded_extra_signals` is {"spec": "data_spec or condition_spec"}.
  -- Forward extra signals to output ports
  trueOut_spec <= data_spec or condition_spec;
  falseOut_spec <= data_spec or condition_spec;

  inner : entity work.handshake_cond_br_2_inner(arch)
    port map(
      clk => clk,
      rst => rst,
      -- Note: these port forwardings are generated by `generate_inner_port_forwarding`.
      data => data,
      data_valid => data_valid,
      data_ready => data_ready,
      condition => condition,
      condition_valid => condition_valid,
      condition_ready => condition_ready,
      trueOut => trueOut,
      trueOut_valid => trueOut_valid,
      trueOut_ready => trueOut_ready,
      falseOut => falseOut,
      falseOut_valid => falseOut_valid,
      falseOut_ready => falseOut_ready
    );
end architecture;
-- Signal manager generation info: handshake_cond_br_2, {'type': 'normal', 'in_ports': [{'name': 'data', 'bitwidth': 32, 'extra_signals': {'spec': 1}}, {'name': 'condition', 'bitwidth': 1, 'extra_signals': {'spec': 1}}], 'out_ports': [{'name': 'trueOut', 'bitwidth': 32, 'extra_signals': {'spec': 1}}, {'name': 'falseOut', 'bitwidth': 32, 'extra_signals': {'spec': 1}}], 'extra_signals': {'spec': 1}}
```

## `muli` (buffered signal manager)

```vhdl
-- Note: Headers and entity are generated by `generate_entity`.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.types.all;

-- Entity of signal manager
entity handshake_muli_0 is
  port(
    clk : in std_logic;
    rst : in std_logic;
    lhs : in std_logic_vector(32 - 1 downto 0);
    lhs_valid : in std_logic;
    lhs_ready : out std_logic;
    lhs_spec : in std_logic_vector(1 - 1 downto 0);
    rhs : in std_logic_vector(32 - 1 downto 0);
    rhs_valid : in std_logic;
    rhs_ready : out std_logic;
    rhs_spec : in std_logic_vector(1 - 1 downto 0);
    result : out std_logic_vector(32 - 1 downto 0);
    result_valid : out std_logic;
    result_ready : in std_logic;
    result_spec : out std_logic_vector(1 - 1 downto 0)
  );
end entity;

-- Architecture of signal manager (buffered)
architecture arch of handshake_muli_0 is
  signal buff_in, buff_out : std_logic_vector(1 - 1 downto 0);
  signal transfer_in, transfer_out : std_logic;
begin
  -- Transfer signal assignments
  transfer_in <= lhs_valid and lhs_ready;
  transfer_out <= result_valid and result_ready;

  -- Note: `forwarded_extra_signals` is {"spec": "lhs_spec or rhs_spec"}.
  -- Concat/split extra signals for buffer input/output
  buff_in(0 downto 0) <= lhs_spec or rhs_spec;
  result_spec <= buff_out(0 downto 0);

  inner : entity work.handshake_muli_0_inner(arch)
    port map(
      clk => clk,
      rst => rst,
      -- Note: these port forwardings are generated by `generate_inner_port_forwarding`.
      lhs => lhs,
      lhs_valid => lhs_valid,
      lhs_ready => lhs_ready,
      rhs => rhs,
      rhs_valid => rhs_valid,
      rhs_ready => rhs_ready,
      result => result,
      result_valid => result_valid,
      result_ready => result_ready
    );

  -- Generate ofifo to store extra signals
  -- num_slots = 4, bitwidth = 1
  buff : entity work.handshake_muli_0_buff(arch)
    port map(
      clk => clk,
      rst => rst,
      ins => buff_in,
      ins_valid => transfer_in,
      ins_ready => open,
      outs => buff_out,
      outs_valid => open,
      outs_ready => transfer_out
    );
end architecture;
-- Signal manager generation info: handshake_muli_0, {'type': 'buffered', 'latency': 4, 'in_ports': [{'name': 'lhs', 'bitwidth': 32, 'extra_signals': {'spec': 1}}, {'name': 'rhs', 'bitwidth': 32, 'extra_signals': {'spec': 1}}], 'out_ports': [{'name': 'result', 'bitwidth': 32, 'extra_signals': {'spec': 1}}], 'extra_signals': {'spec': 1}}
```

## `fork` (concat signal manager)

```vhdl
-- Note: Headers and entity are generated by `generate_entity`.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.types.all;

-- Entity of signal manager
entity handshake_fork_1 is
  port(
    clk : in std_logic;
    rst : in std_logic;
    ins : in std_logic_vector(32 - 1 downto 0);
    ins_valid : in std_logic;
    ins_ready : out std_logic;
    ins_spec : in std_logic_vector(1 - 1 downto 0);
    outs : out data_array(4 - 1 downto 0)(32 - 1 downto 0);
    outs_valid : out std_logic_vector(4 - 1 downto 0);
    outs_ready : in std_logic_vector(4 - 1 downto 0);
    outs_0_spec : out std_logic_vector(1 - 1 downto 0);
    outs_1_spec : out std_logic_vector(1 - 1 downto 0);
    outs_2_spec : out std_logic_vector(1 - 1 downto 0);
    outs_3_spec : out std_logic_vector(1 - 1 downto 0)
  );
end entity;

-- Architecture of signal manager (concat)
architecture arch of handshake_fork_1 is
  -- Concatenated data and extra signals
  signal ins_inner : std_logic_vector(33 - 1 downto 0);
  signal outs_inner : data_array(4 - 1 downto 0)(33 - 1 downto 0);
begin
  -- Concatenate data and extra signals
  ins_inner(32 - 1 downto 0) <= ins;
  ins_inner(32 downto 32) <= ins_spec;
  outs(0) <= outs_inner(0)(32 - 1 downto 0);
  outs_0_spec <= outs_inner(0)(32 downto 32);
  outs(1) <= outs_inner(1)(32 - 1 downto 0);
  outs_1_spec <= outs_inner(1)(32 downto 32);
  outs(2) <= outs_inner(2)(32 - 1 downto 0);
  outs_2_spec <= outs_inner(2)(32 downto 32);
  outs(3) <= outs_inner(3)(32 - 1 downto 0);
  outs_3_spec <= outs_inner(3)(32 downto 32);

  -- Note: Inner fork is generated with concatenated bitwidth
  inner : entity work.handshake_fork_1_inner(arch)
    port map(
      clk => clk,
      rst => rst,
      -- Note: `ins` is forwarded to concatenated `ins_inner`.
      ins => ins_inner,
      ins_valid => ins_valid,
      ins_ready => ins_ready,
      -- Note: `outs` is forwarded to concatenated `outs_inner`.
      outs => outs_inner,
      outs_valid => outs_valid,
      outs_ready => outs_ready
    );
end architecture;
-- Signal manager generation info: handshake_fork_1, {'type': 'concat', 'in_ports': [{'name': 'ins', 'bitwidth': 32, 'extra_signals': {'spec': 1}}], 'out_ports': [{'name': 'outs', 'bitwidth': 32, 'extra_signals': {'spec': 1}, '2d': True, 'size': 4}], 'extra_signals': {'spec': 1}}
```

## `mux` (bbmerge signal manager)

```vhdl
-- Note: Headers and entity are generated by `generate_entity`.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.types.all;

-- Entity of signal manager
entity handshake_mux_0 is
  port(
    clk : in std_logic;
    rst : in std_logic;
    ins : in data_array(2 - 1 downto 0)(32 - 1 downto 0);
    ins_valid : in std_logic_vector(2 - 1 downto 0);
    ins_ready : out std_logic_vector(2 - 1 downto 0);
    -- Note: spec is only present at index 1 (not 0).
    ins_1_spec : in std_logic_vector(1 - 1 downto 0);
    index : in std_logic_vector(1 - 1 downto 0);
    index_valid : in std_logic;
    index_ready : out std_logic;
    outs : out std_logic_vector(32 - 1 downto 0);
    outs_valid : out std_logic;
    outs_ready : in std_logic;
    outs_spec : out std_logic_vector(1 - 1 downto 0)
  );
end entity;

-- Architecture of signal manager (bbmerge)
architecture arch of handshake_mux_0 is
  -- Lacking spec inputs
  signal ins_0_spec : std_logic_vector(0 downto 0);
  -- Concatenated data and extra signals
  signal ins_inner : data_array(2 - 1 downto 0)(33 - 1 downto 0);
  signal outs_inner : std_logic_vector(33 - 1 downto 0);
begin
  -- Assign default spec bit values if not provided
  ins_0_spec <= "0";

  -- Concatenate data and extra signals
  ins_inner(0)(32 - 1 downto 0) <= ins(0);
  ins_inner(0)(32 downto 32) <= ins_0_spec;
  ins_inner(1)(32 - 1 downto 0) <= ins(1);
  ins_inner(1)(32 downto 32) <= ins_1_spec;
  outs <= outs_inner(32 - 1 downto 0);
  outs_spec <= outs_inner(32 downto 32);

  -- Note: Inner mux is generated with concatenated bitwidth
  inner : entity work.handshake_mux_0_inner(arch)
    port map(
      clk => clk,
      rst => rst,
      -- Note: `ins` is forwarded to concatenated `ins_inner`.
      ins => ins_inner,
      ins_valid => ins_valid,
      ins_ready => ins_ready,
      -- Note: `index` is not concatenated and directly forwarded to external signal.
      index => index,
      index_valid => index_valid,
      index_ready => index_ready,
      -- Note: `outs` is forwarded to concatenated `outs_inner`.
      outs => outs_inner,
      outs_valid => outs_valid,
      outs_ready => outs_ready
    );
end architecture;
-- Signal manager generation info: handshake_mux_0, {'type': 'bbmerge', 'in_ports': [{'name': 'ins', 'bitwidth': 32, '2d': True, 'size': 2, 'extra_signals_list': [{}, {'spec': 1}]}, {'name': 'index', 'bitwidth': 1, 'extra_signals': {}}], 'out_ports': [{'name': 'outs', 'bitwidth': 32, 'extra_signals': {'spec': 1}}], 'size': 2, 'data_in_name': 'ins', 'index_name': 'index', 'out_extra_signals': {'spec': 1}, 'spec_inputs': [1]}
```

## `load` (custom signal manager)

```vhdl
-- Note: Headers and entity are generated by `generate_entity`.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.types.all;

-- Entity of signal manager
entity handshake_load_0 is
  port(
    clk : in std_logic;
    rst : in std_logic;
    addrIn : in std_logic_vector(10 - 1 downto 0);
    addrIn_valid : in std_logic;
    addrIn_ready : out std_logic;
    addrIn_spec : in std_logic_vector(1 - 1 downto 0);
    dataFromMem : in std_logic_vector(32 - 1 downto 0);
    dataFromMem_valid : in std_logic;
    dataFromMem_ready : out std_logic;
    addrOut : out std_logic_vector(10 - 1 downto 0);
    addrOut_valid : out std_logic;
    addrOut_ready : in std_logic;
    dataOut : out std_logic_vector(32 - 1 downto 0);
    dataOut_valid : out std_logic;
    dataOut_ready : in std_logic;
    dataOut_spec : out std_logic_vector(1 - 1 downto 0)
  );
end entity;

-- Architecture of load signal manager
architecture arch of handshake_load_0 is
  signal addrIn_ready_inner : std_logic;
  signal tfifo_ready : std_logic;
  -- Concatenated signals
  signal addrIn_inner : std_logic_vector(1 - 1 downto 0);
  signal dataOut_inner : std_logic_vector(1 - 1 downto 0);
  -- Transfer signals
  signal transfer_in, transfer_out : std_logic;
begin
  -- addrIn is ready only when inner load and tfifo are ready
  addrIn_ready <= addrIn_ready_inner and tfifo_ready;

  -- Transfer signal assignments
  transfer_in <= addrIn_valid and addrIn_ready_inner;
  transfer_out <= dataOut_valid and dataOut_ready;

  -- Concatenate extra signals
  addrIn_inner(0 downto 0) <= addrIn_spec;
  dataOut_spec <= dataOut_inner(0 downto 0);

  -- Buffer to store extra signals for in-flight memory requests
  -- Use tfifo because the latency is unknown
  tfifo : entity work.handshake_load_0_tfifo(arch)
    port map(
      clk => clk,
      rst => rst,
      ins => addrIn_inner,
      ins_valid => transfer_in,
      ins_ready => tfifo_ready,
      outs => dataOut_inner,
      outs_valid => open,
      outs_ready => transfer_out
    );

  inner : entity work.handshake_load_0_inner(arch)
    port map(
      clk => clk,
      rst => rst,
      addrIn => addrIn,
      addrIn_valid => addrIn_valid,
      addrIn_ready => addrIn_ready_inner,
      addrOut => addrOut,
      addrOut_valid => addrOut_valid,
      addrOut_ready => addrOut_ready,
      dataFromMem => dataFromMem,
      dataFromMem_valid => dataFromMem_valid,
      dataFromMem_ready => dataFromMem_ready,
      dataOut => dataOut,
      dataOut_valid => dataOut_valid,
      dataOut_ready => dataOut_ready
    );
end architecture;
```
