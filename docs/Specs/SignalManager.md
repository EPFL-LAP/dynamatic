# Signal Manager Examples

The signal manager wraps each unit (e.g., `addi`, `buffer`, etc.) and forwards extra signals.

As you can see from the source code, typical signal managers can be reused across many ops. You donâ€™t need to reimplement a signal manager every time you introduce a new op. Additionally, when adding a new type of extra signal, you only need to update a small number of signal managers.

The generator code may seem abstract without concrete examples, so here are some generated signal managers.

Comments starting with `Note:` are for clarity and are not part of the generated output.

## `cond_br` (normal signal manager)

```vhdl
-- Note: Headers and entity are generated by `generate_entity`.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.types.all;

-- Entity of signal manager
entity handshake_cond_br_2 is
  port(
    clk : in std_logic;
    rst : in std_logic;
    data : in std_logic_vector(32 - 1 downto 0);
    data_valid : in std_logic;
    data_ready : out std_logic;
    data_spec : in std_logic_vector(1 - 1 downto 0);
    condition : in std_logic_vector(1 - 1 downto 0);
    condition_valid : in std_logic;
    condition_ready : out std_logic;
    condition_spec : in std_logic_vector(1 - 1 downto 0);
    trueOut : out std_logic_vector(32 - 1 downto 0);
    trueOut_valid : out std_logic;
    trueOut_ready : in std_logic;
    trueOut_spec : out std_logic_vector(1 - 1 downto 0);
    falseOut : out std_logic_vector(32 - 1 downto 0);
    falseOut_valid : out std_logic;
    falseOut_ready : in std_logic;
    falseOut_spec : out std_logic_vector(1 - 1 downto 0)
  );
end entity;

-- Architecture of signal manager (normal)
architecture arch of handshake_cond_br_2 is
begin
  -- Note: `forwarded_extra_signals` is {"spec": "data_spec or condition_spec"}.
  -- Forward extra signals to output ports
  trueOut_spec <= data_spec or condition_spec;
  falseOut_spec <= data_spec or condition_spec;

  inner : entity work.handshake_cond_br_2_inner(arch)
    port map(
      clk => clk,
      rst => rst,
      -- Note: these port forwardings are generated by `generate_inner_port_forwarding`.
      data => data,
      data_valid => data_valid,
      data_ready => data_ready,
      condition => condition,
      condition_valid => condition_valid,
      condition_ready => condition_ready,
      trueOut => trueOut,
      trueOut_valid => trueOut_valid,
      trueOut_ready => trueOut_ready,
      falseOut => falseOut,
      falseOut_valid => falseOut_valid,
      falseOut_ready => falseOut_ready
    );
end architecture;
-- Signal manager generation info: handshake_cond_br_2, {'type': 'normal', 'in_ports': [{'name': 'data', 'bitwidth': 32, 'extra_signals': {'spec': 1}}, {'name': 'condition', 'bitwidth': 1, 'extra_signals': {'spec': 1}}], 'out_ports': [{'name': 'trueOut', 'bitwidth': 32, 'extra_signals': {'spec': 1}}, {'name': 'falseOut', 'bitwidth': 32, 'extra_signals': {'spec': 1}}], 'extra_signals': {'spec': 1}}
```

## `muli` (buffered signal manager)

```vhdl
-- Note: Headers and entity are generated by `generate_entity`.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.types.all;

-- Entity of signal manager
entity handshake_muli_0 is
  port(
    clk : in std_logic;
    rst : in std_logic;
    lhs : in std_logic_vector(32 - 1 downto 0);
    lhs_valid : in std_logic;
    lhs_ready : out std_logic;
    lhs_spec : in std_logic_vector(1 - 1 downto 0);
    rhs : in std_logic_vector(32 - 1 downto 0);
    rhs_valid : in std_logic;
    rhs_ready : out std_logic;
    rhs_spec : in std_logic_vector(1 - 1 downto 0);
    result : out std_logic_vector(32 - 1 downto 0);
    result_valid : out std_logic;
    result_ready : in std_logic;
    result_spec : out std_logic_vector(1 - 1 downto 0)
  );
end entity;

-- Architecture of signal manager (buffered)
architecture arch of handshake_muli_0 is
  signal buff_in, buff_out : std_logic_vector(1 - 1 downto 0);
  signal transfer_in, transfer_out : std_logic;
begin
  -- Transfer signal assignments
  transfer_in <= lhs_valid and lhs_ready;
  transfer_out <= result_valid and result_ready;

  -- Note: `forwarded_extra_signals` is {"spec": "lhs_spec or rhs_spec"}.
  -- Concat/split extra signals for buffer input/output
  buff_in(0 downto 0) <= lhs_spec or rhs_spec;
  result_spec <= buff_out(0 downto 0);

  inner : entity work.handshake_muli_0_inner(arch)
    port map(
      clk => clk,
      rst => rst,
      -- Note: these port forwardings are generated by `generate_inner_port_forwarding`.
      lhs => lhs,
      lhs_valid => lhs_valid,
      lhs_ready => lhs_ready,
      rhs => rhs,
      rhs_valid => rhs_valid,
      rhs_ready => rhs_ready,
      result => result,
      result_valid => result_valid,
      result_ready => result_ready
    );

  -- Generate ofifo to store extra signals
  -- num_slots = 4, bitwidth = 1
  buff : entity work.handshake_muli_0_buff(arch)
    port map(
      clk => clk,
      rst => rst,
      ins => buff_in,
      ins_valid => transfer_in,
      ins_ready => open,
      outs => buff_out,
      outs_valid => open,
      outs_ready => transfer_out
    );
end architecture;
-- Signal manager generation info: handshake_muli_0, {'type': 'buffered', 'latency': 4, 'in_ports': [{'name': 'lhs', 'bitwidth': 32, 'extra_signals': {'spec': 1}}, {'name': 'rhs', 'bitwidth': 32, 'extra_signals': {'spec': 1}}], 'out_ports': [{'name': 'result', 'bitwidth': 32, 'extra_signals': {'spec': 1}}], 'extra_signals': {'spec': 1}}
```

The illustration of this circuit (by @murphe67) looks like this:

<img src="./figs/SignalManager/muli.png" width="700" />

## `fork` (concat signal manager)

```vhdl
-- Note: Headers and entity are generated by `generate_entity`.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.types.all;

-- Entity of signal manager
entity handshake_fork_1 is
  port(
    clk : in std_logic;
    rst : in std_logic;
    ins : in std_logic_vector(32 - 1 downto 0);
    ins_valid : in std_logic;
    ins_ready : out std_logic;
    ins_spec : in std_logic_vector(1 - 1 downto 0);
    outs : out data_array(4 - 1 downto 0)(32 - 1 downto 0);
    outs_valid : out std_logic_vector(4 - 1 downto 0);
    outs_ready : in std_logic_vector(4 - 1 downto 0);
    outs_0_spec : out std_logic_vector(1 - 1 downto 0);
    outs_1_spec : out std_logic_vector(1 - 1 downto 0);
    outs_2_spec : out std_logic_vector(1 - 1 downto 0);
    outs_3_spec : out std_logic_vector(1 - 1 downto 0)
  );
end entity;

-- Architecture of signal manager (concat)
architecture arch of handshake_fork_1 is
  -- Concatenated data and extra signals
  signal ins_inner : std_logic_vector(33 - 1 downto 0);
  signal outs_inner : data_array(4 - 1 downto 0)(33 - 1 downto 0);
begin
  -- Concatenate data and extra signals
  ins_inner(32 - 1 downto 0) <= ins;
  ins_inner(32 downto 32) <= ins_spec;
  outs(0) <= outs_inner(0)(32 - 1 downto 0);
  outs_0_spec <= outs_inner(0)(32 downto 32);
  outs(1) <= outs_inner(1)(32 - 1 downto 0);
  outs_1_spec <= outs_inner(1)(32 downto 32);
  outs(2) <= outs_inner(2)(32 - 1 downto 0);
  outs_2_spec <= outs_inner(2)(32 downto 32);
  outs(3) <= outs_inner(3)(32 - 1 downto 0);
  outs_3_spec <= outs_inner(3)(32 downto 32);

  -- Note: Inner fork is generated with concatenated bitwidth
  inner : entity work.handshake_fork_1_inner(arch)
    port map(
      clk => clk,
      rst => rst,
      -- Note: `ins` is forwarded to concatenated `ins_inner`.
      ins => ins_inner,
      ins_valid => ins_valid,
      ins_ready => ins_ready,
      -- Note: `outs` is forwarded to concatenated `outs_inner`.
      outs => outs_inner,
      outs_valid => outs_valid,
      outs_ready => outs_ready
    );
end architecture;
-- Signal manager generation info: handshake_fork_1, {'type': 'concat', 'in_ports': [{'name': 'ins', 'bitwidth': 32, 'extra_signals': {'spec': 1}}], 'out_ports': [{'name': 'outs', 'bitwidth': 32, 'extra_signals': {'spec': 1}, '2d': True, 'size': 4}], 'extra_signals': {'spec': 1}}
```

## `spec_commit` (concat signal manager)

When `spec_commit` carries both `spec: i1` and `tag0: i8`, it uses the concat signal manager to forward extra signals except for `spec`. `spec` is propagated to the inner unit.

```vhdl
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.types.all;

-- Entity of signal manager
entity spec_commit0 is
  port(
    clk : in std_logic;
    rst : in std_logic;
    ins : in std_logic_vector(32 - 1 downto 0);
    ins_valid : in std_logic;
    ins_ready : out std_logic;
    ins_spec : in std_logic_vector(1 - 1 downto 0);
    ins_tag0 : in std_logic_vector(8 - 1 downto 0);
    ctrl : in std_logic_vector(1 - 1 downto 0);
    ctrl_valid : in std_logic;
    ctrl_ready : out std_logic;
    outs : out std_logic_vector(32 - 1 downto 0);
    outs_valid : out std_logic;
    outs_ready : in std_logic;
    outs_tag0 : out std_logic_vector(8 - 1 downto 0)
  );
end entity;

-- Architecture of signal manager (concat)
architecture arch of spec_commit0 is
  -- Concatenated data and extra signals
  signal ins_inner : std_logic_vector(40 - 1 downto 0);
  signal outs_inner : std_logic_vector(40 - 1 downto 0);
begin
  -- Concatenate data and extra signals
  -- Note: Only tag0 is concatenated and spec is not as only tag0 is specified in extra_signals parameter.
  ins_inner(32 - 1 downto 0) <= ins;
  ins_inner(39 downto 32) <= ins_tag0;
  outs <= outs_inner(32 - 1 downto 0);
  outs_tag0 <= outs_inner(39 downto 32);

  inner : entity work.spec_commit0_inner(arch)
    port map(
      clk => clk,
      rst => rst,
      ins => ins_inner,
      ins_valid => ins_valid,
      ins_ready => ins_ready,
      -- Note: `spec` is forwarded.
      ins_spec => ins_spec,
      -- Note: Since `ctrl` is in `ignore_ports`, extra signals are not concatenated, and the original `ctrl` signal is forwarded.
      ctrl => ctrl,
      ctrl_valid => ctrl_valid,
      ctrl_ready => ctrl_ready,
      outs => outs_inner,
      outs_valid => outs_valid,
      outs_ready => outs_ready
      -- Note: since `outs` originally lacks `spec`, it is not forwarded.
    );
end architecture;
-- Signal manager generation info: spec_commit0, {'type': 'concat', 'in_ports': [{'name': 'ins', 'bitwidth': 32, 'extra_signals': {'spec': 1, 'tag0': 8}}, {'name': 'ctrl', 'bitwidth': 1}], 'out_ports': [{'name': 'outs', 'bitwidth': 32, 'extra_signals': {'tag0': 8}}], 'extra_signals': {'tag0': 8}, 'ignore_ports': ['ctrl']}
```

## `load` (custom signal manager)

```vhdl
-- Note: Headers and entity are generated by `generate_entity`.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.types.all;

-- Entity of signal manager
entity handshake_load_0 is
  port(
    clk : in std_logic;
    rst : in std_logic;
    addrIn : in std_logic_vector(10 - 1 downto 0);
    addrIn_valid : in std_logic;
    addrIn_ready : out std_logic;
    addrIn_spec : in std_logic_vector(1 - 1 downto 0);
    dataFromMem : in std_logic_vector(32 - 1 downto 0);
    dataFromMem_valid : in std_logic;
    dataFromMem_ready : out std_logic;
    addrOut : out std_logic_vector(10 - 1 downto 0);
    addrOut_valid : out std_logic;
    addrOut_ready : in std_logic;
    dataOut : out std_logic_vector(32 - 1 downto 0);
    dataOut_valid : out std_logic;
    dataOut_ready : in std_logic;
    dataOut_spec : out std_logic_vector(1 - 1 downto 0)
  );
end entity;

-- Architecture of load signal manager
architecture arch of handshake_load_0 is
  signal addrIn_ready_inner : std_logic;
  signal ofifo_ready : std_logic;
  -- Concatenated signals
  signal addrIn_inner : std_logic_vector(1 - 1 downto 0);
  signal dataOut_inner : std_logic_vector(1 - 1 downto 0);
  -- Transfer signals
  signal transfer_in, transfer_out : std_logic;
begin
  -- addrIn_ready <= addrIn_ready_inner and ofifo_ready; -- Conservative
  addrIn_ready <= addrIn_ready_inner; -- Assuming MC latency is 1 and ofifo is always ready

  -- Transfer signal assignments
  transfer_in <= addrIn_valid and addrIn_ready_inner;
  transfer_out <= dataOut_valid and dataOut_ready;

  -- Concatenate extra signals
  addrIn_inner(0 downto 0) <= addrIn_spec;
  dataOut_spec <= dataOut_inner(0 downto 0);

  -- Buffer to store extra signals for in-flight memory requests
  -- LoadOp is assumed to be connected to a memory controller
  -- Use ofifo with latency 1 (MC latency)
  ofifo : entity work.handshake_load_0_ofifo(arch)
    port map(
      clk => clk,
      rst => rst,
      ins => addrIn_inner,
      ins_valid => transfer_in,
      ins_ready => ofifo_ready,
      outs => dataOut_inner,
      outs_valid => open,
      outs_ready => transfer_out
    );

  inner : entity work.handshake_load_0_inner(arch)
    port map(
      clk => clk,
      rst => rst,
      addrIn => addrIn,
      addrIn_valid => addrIn_valid,
      addrIn_ready => addrIn_ready_inner,
      addrOut => addrOut,
      addrOut_valid => addrOut_valid,
      addrOut_ready => addrOut_ready,
      dataFromMem => dataFromMem,
      dataFromMem_valid => dataFromMem_valid,
      dataFromMem_ready => dataFromMem_ready,
      dataOut => dataOut,
      dataOut_valid => dataOut_valid,
      dataOut_ready => dataOut_ready
    );
end architecture;
```

## Signal manager handling multiple extra signals

Here is an illustration (by @murphe67) of the `muli` signal manager handling both `spec` and `tag`. The forwarding behavior differs between themâ€”`spec` ORs two signals, while `tag` takes one and discards the other. You can define the forwarding semantics in **a single place** (`_get_forwarded_expression`), ensuring reuse across all instances.

<img src="./figs/SignalManager/muli_tag.png" />
